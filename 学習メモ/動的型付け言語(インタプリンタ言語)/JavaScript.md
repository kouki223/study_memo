- 学習ソース
    - progate
        - https://prog-8.com/courses/es6
    - JavaScript primer
        https://ja.m.wikibooks.org/wiki/JavaScript/void#:~:text=void%20%E3%81%AF%E3%80%81JavaScript%20%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E3%82%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%89,%E6%89%8B%E6%AE%B5%E3%81%A8%E3%81%97%E3%81%A6%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82
- ***JavaScripの概要***
    - Java Scriptって何？
        - 主にWebブラウザの中で動くプログラミング言語
            - 動的型付け言語(インタプリンタ言語)である
        - Webアプリケーションにおいてクライアントサイドでもサーバーサイドでも動作する言語
            - 動的なページを作るのに必須になっている
                - 操作に応じて表示が変わる
                - データの取得
                    - Webサーバーと通信を行う
                - データの更新
            - htmlとcssのみではできない事をしている
        - 現在のWebサイトには欠かせない存在になっている
            - Webアプリケーション　＝＞　Webアプリケーションのように動くWebサイト
        - JavaScriptはNode.jsでも使用されている
            - デスクトップアプリ
            - スマートフォンアプリ
            - IoTデバイス
                - などでも使用することができている
        - 元々、Netscape Navigatorというブラウザ向けに開発された言語
            - 影響を受けた言語
                - C
                - Java
                - Self
                - Scheme
            - 大部分がオブジェクトで構成される
                - オブジェクト同士の関係性で成り立っている
                    - オブジェクトの種類
                        - ECMAScriptの仕様で定められたオブジェクト
                        - 実行環境が定義したオブジェクト
                        - ユーザー（自分）が定義したオブジェクト
    - ランタイムシステム
        - Node.js
            - V8エンジンを使ってJavaScriptをサーバーサイドでも使えるようにしたもの
                - APIやライブラリを提供する 
        - DENO
            - JavaScriptとTypeScriptの実行環境を提供する
        - BUN
            - JavaScriptCoreエンジンを使用する
    - ランタイムエンジン
        - V8エンジン　＝＞　Googleが開発　＝＞　高速な実行環境
        - SpiderMonkey
        - JavaScriptCore
        - Chakra
        - Nashorn
    - ECMAScript
        - 仕様
            - どの実行環境でも共有の環境
                - JavaScriptはこのECMAScriptnによって仕様が決まっている
    - JavaScriptの仕様は毎年更新される
        - ECMAScriptは毎年更新される
            - JavaScriptには新しい構文や機能が増え続ける
                - ECMAScriptは後方互換性に優れる
                    - 学びは無駄にならない
    - JSのバージョン
        - ES2015（ES6)
            - JSは現在、Web開発において必須の存在となっている
                - 旧バージョンのJS5→新バージョンES2015（ES6)
                    - 旧バージョンよりも効率的にコードを書く事ができるようになったコード
    - scrict mode
        - 厳格な実行モード
            - 古く安全でない機能や構文が1部禁止される
                - use strictという文字列を関数orファイルの先頭に記載するとそのスコープではstrict modeが実行される
                    - moduleの実行コンテクストではデフォルトになっている
                        - 禁止される例：
                            - eval
                            - with
                                - 上記のようなレガシーな構文を禁止する
                                    - 明らかな問題を含んだコードに対しては早期に例外を投げる事で開発者が間違いを気づくようにする
    - 実行コンテクスト
        - Script
            - デフォルトがstrict modeではない
        - Module
            - デフォルトがstrict modeになっている
                - Moduleの実行コンテクストでのみ実行される
    - 大文字と小文字を区別する
        - nemeとNAMEは違う言語として認識される
    - 予約語を持つ言語
        - 特別な意味を持つキーワード
    - 文と式
        - JavaScriptのソースコードを構成する文と式という構文的な概念について
            - 文と式の違いを理解する
                - どの場合にセミコロンを入れるかがわかるようになる
        - 文（Statement）毎に処理し、文末は;（セミコロン）で区切る
            - 特殊なルールでセミコロンがないぶんも自動的にセミコロンが代入される仕組みがある
                - 暗黙的な仕様に頼る事は進められない
    - データ型
        - JSは動的型付け言語のため静的型付け言語のような変数の型はない
            - しかし、文字列・数値・真偽値といった値の型は存在する
        - プリミティブ型　＝＞　基本型
            - イミュータブルな値という特性を持っている
                - 文字列であっても一度、作成したら変更できないイミュータブルの特性を持つ
            - 真偽値（Boolean）
                - trueまたはfalseのデータ型
            - 数値（Number）
                - 42 や 3.14159 などの数値のデータ型
            - 巨大な整数（BigInt）
                - ES2020から追加された9007199254740992nなど
                    - 任意精度の整数のデータ型
            - 文字列（String）
                - "JavaScript" などの文字列のデータ型
            - undefined
                - 値が未定義であることを意味するデータ型
            - null
                - 値が存在しないことを意味するデータ型
            - シンボル（Symbol）
                - ES2015から追加された一意で不変な値のデータ型
        - オブジェクト型
            - 複数のプリミティブ型 or オブジェクトからなる集合
                - 作成した後も値を変更する事ができる
                    - 値の変更というものは値自体を変更するのではなく、値の参照を変更するという事になる
            - プリミティブ型以外のデータ
                - オブジェクト、配列、関数、クラス、正規表現、Date
- ***JavaScriptの仕様***
    - 空白の扱い
        - 空白は個数が変わっても認識は変わらない
    - 出力
        - console.log("○○");
            - ("○○");内の○○を出力する事ができる
                - ()内の文字列は” or ’ のどちらかで囲む必要がある
                - 文末の;は必須ではないが記載する方が好ましい
    - コメントアウト
        - JavaScriptにおけるコメントの書き方
            - コメントはプログラムとして評価されない
                - ソースコードに対する説明を書くために利用する
        - １行のみのコメントアウト
            - //以降から行末までがコメントアウトされる
        - 範囲でのコメントアウト
            - /*から*/までの範囲がコメントアウトされる
        - HTML-likeコメントは後方互換性のためだけに存在する
    - 計算
        - 数値の計算
            - クウォーテーションは無しで計算式を記載する
                - console.log(3+4);
            - 掛け算「*」
            - 割り算「/」
            - 余りの計算「%」
        - 省略した記載方法（省略形）
            - X = X + 10 → X += 10
            - X= X - 10 → X -= 10
            - X= X * 10 → X *= 10
            - X= X / 10 →X /= 10
            - X= X % 10 → X %= 10
        - 文字列の連結
            - 連結させたい文字列同士を記号”＋”で囲む
                - 「"にんじゃ" + "わんこ"」→「"にんじゃわんこ"」
        - 文字列の連結と数値の計算の違い
            - 数値をクウォーテーションで囲んで記載すると計算されずに文字列として認識されて出力される
                - console.log(”3+4”);
        - ”＝”の意味
            - 等しいという意味ではなう右辺を左辺に代入するという意味
    - 変数の宣言（全て共通）
        - 変数同士を,（カンマ）で区切る
            - 同時に複数の変数を定義できる
        - 変数の宣言規則
            - 半角のアルファベット
            - _（アンダースコア）
            - $（ダラー）
            - 数字
                - これらを組み合わせた名前にする
        - 変数名は数字から開始できない
        - 予約語と被る名前は利用できない
    - 変数（let）
        - データ（値）の入れ物（箱）
            - 箱の名前が”変数名”
        - letは初期値を指定しない変数も定義する事ができる
            - 初期値が指定されない変数はundefinedで初期化される
        - なぜ変数を使用するのか？
            - 繰り返し使う事ができる
                - 例：同じ処理を複数回使いたい場合
                    - Aさん＋”おはようございます”
                    - Bさん＋”おはようございます”
                        - ”おはようござます”を変数で定義しておけば繰り返し使える
            - 変更に対応しやすい
                - 変更箇所が少ない
                    - 例:上記のような繰り返し同じ処理がある場合にも変数を定義していれば変数の値を変更する事で全体に変更がかかる
            - 値の意味がわかりやすい
                - 可読性が高くなる
        - 変数の定義
            - letでこれから変数名を定義しますという宣言になる
                - let 変数名 = 値
        - 変数の上書き
            - 定義された変数は変数名=上書きする内容とする事で再定義する事ができる
                - 変数名＝上書きする値
        - 変数の更新
            - 変数は変数自身に付け加えて更新する事もできる
                - let number = 5;
                - number = number+5;
                    - 更新した値は更新した値が保持される
        - 変数の命名ルール
            - ES6での命名ルール
                - 良い例
                    - 英単語を使用する
                        - name
                    - 2単語になる場合には大文字で区切る
                        - firstName
                - 悪い例
                    - 数字開始
                        - エラーになってしまう
                    - 日本語
                        - 望ましくない
                    - ローマ字
                        - 望ましくない
        - 変数の使用
            - 変数の定義を行い定義した変数に対して文字列などデータを代入する事で変数名を呼び出した際に代入したデータが出力される
                - 変数を呼び出す時にはクウォーテーションで囲まないという事に注意する
            - 変数は代入されているデータに応じて計算・連結する事ができる
                - 文字列の場合
                    - 変数に代入されていない文字列同様に使用する事ができる
                - 数値の場合
                    - 変数に代入されていない数値同様に計算などの処理を行う事ができる
    - 定数に近い変数を定義できる宣言(const)
        - 定数の定義
            - 一度、定義すると毎回同じ値を返す
        - const
            - constは定数ではない
                - constは再代入禁止の変数なのであってオブジェクトの値をプロパティを介して変更する事ができる 
            - 再代入禁止の変数
                - その変数が参照する値を定義する
                    - 再代入する必要がない場合に優先的に使用される変数
                        - 再代入が必要な場合にはletを使う
            - 実質的に的に
    - 変数（var）
        - letと同じように使う事ができる変数
        - letとconstとの違い（問題点）
            - 同じキーワードに対して再代入できてしまう点
                - 変数の上書きをしても構文エラーが起きない
        - 問題が出現したため新しくconstとletが追加された
            - var自体を改善しなかった理由
                - 後方互換性
    - 値の評価と表示
        - 変数の宣言をする事で値に名前をつける事ができる
            - 変数の宣言は返り値はない
    - 実行環境
        - ブラウザの違いや実行環境によってコードが動いた結果が変わる事がある
    - REPL（read–eval–print loop）
        - ブラウザにはWebコンソールという試したいコードを実行するツールがある
            - 変数の宣言をした結果はundifinedが帰ってくる
                - 変数の宣言は戻り値を持たない
                    - 変数を呼び出すと値が返ってくる
        - リロードするまで変数の宣言などが保たれる
            - 再定義などにはエラーが起きてしまった場合にはリロードする
    - JavaScriptを読み込む方法
        - WebサイトはHTMLで表示される
            - HTMLでJavaScriptを読み込む事でJavaScriptを実行する事ができる
    - Consple API
    - リテラル
        - リテラルを使う事で簡単に定義する事ができる
            - 構文として定義されたもの
        - リテラル表現があるプリミティブ型とオブジェクト型
            - プリミティブ型
                - 真偽値
                    - true; false;
                        - 見た目通りに真偽値を示す
                - 数値
                    - 64ビットで数値を表現する
                        - 54ビットを数字の格納
                        - 11ビットを小数点の位置に使う
                        - 1ビットをプラスとマイナスに使う
                    - 整数リテラル
                      - 10進数　＝＞　数値
                      - 2進数　＝＞　ビット演算
                      - 8進数　＝＞　ファイルのパーミッションなど
                      - 16進数  ＝＞　コードポイントやRGB値など
                    - 浮動小数点リテラル
                        - ドットを含んだ数値
                        - eまたはEを含んだ数値
                            - 0から始まる浮動小数点は0を省略して記載する事ができる
                                - JSは.から始まるオブジェクトが多いため省略せずに記載する方が望ましい
                - BigInt
                    - 数値リテラルが扱う事ができる値は決まっている
                        - 上限を超えると正しい結果にならない可能性がある
                    - 数値リテラル　＝＞　64ビット
                    - Bigint ＝＞　任意の精度の整数
                        - 扱う事ができる整数の範囲が大きくなる
                - 文字列
                - null
            - オブジェクト型
                - オブジェクト
                - 配列
                - 正規表現
                    - /スラッシュとスラッシュ/で正規表現のパターン文字を囲む
                        - +や/で始まる特殊な文字が出現する
        - テンプレートリテラル
            - ${定数}とする事で文字列内に変数を埋めこむことができる
                - テンプレートリテラルを使用する場合には文字列全体をバッククォーテーション（`）で囲む必要がある
        - 
    - 条件分岐
        - if文（条件分岐）
            - ある条件が成り立つときだけある処理を行う
                - もし○○ならば●●を行うという処理を作ることができる
                    - if (条件式) {処理内容}　←；は必要なし
            - if文を書く際には中の処理内容はインデントする事を意識する
            - 真偽値
                - if文は検証の結果をtrue or falseの2つで返す
                    - 真　＝　true
                    - 偽　＝　false
            - else
                - if文の真偽値がtrue以外の場合に行う処理
                    - 「もし〇〇なら●●を行う、そうでなければ■■を行う」という処理
                        - if (条件式){trueだった場合の処理内容}else{true以外だった場合の処理内容}
            - else if (条件)
                - if文がtrue以外だった場合にさらに条件を加える際の記載方法
                    
                    ```jsx
                    if (条件1){
                    条件１がtrueだった場合に実行する処理内容
                    }else if(条件1がtrue以外だった場合の条件2){
                    条件2がtrueだった場合の処理内容
                    }else{
                    条件2がtrue以外だった場合の処理内容
                    }
                    ```
                    
            - かつ・または
                - かつ→&&
                    - 条件1&&条件2は条件1かつ条件2という意味になる
                        - 条件全てがtrueであればtrueになる処理
                - または→｜｜
                    - 条件1 || 条件2は条件1または条件2という意味になり
                        - 条件のいずれかがtrueであればtrueを返す処理
        - switch文　if文以外の条件分岐
            - 定数の値によって処理を分岐する方法
                - switch(条件の値){ 処理 }
                    - case 値1: break;
                        - caseの分だけ条件分岐を設定できる
                        - breakを記載する事で条件分岐の終了を定義する事ができる
                
                ```jsx
                const name="kouki"
                switch (name){
                 case(値１):
                     値１が条件と等しい場合に実行される処理
                 break;
                 case(値２):
                     値２が条件と等しい場合に実行される処理
                 break;
                }
                ```
                
            - switch分のcaseどれにも当てはまらなかった場合
                - defaultを設定する
                    - default: 処理 break;
    - 演算子
        - 2項演算子 => 2つのオペランドに対する処理を行う
            - プラス演算子（+）
                - 2つのオペランドである数値を加算する演算子
                    - 整数と浮動小数点どちらもIEEE 754方式が採用されている
                        - どちらも加算する事ができる
            - マイナス演算子（-）
                - 2つのオペランドである数値を減算する演算子
            - 文字列結合演算子（+）
                - 2つのオペランドである文字列を結合する演算子
            - 乗算演算子（*）
                - 2つのオペランドである数値を累乗する演算子
            - 除算演算子（/）
                - 2つのオペランドである数値を徐算する演算子
                    - ０を徐算した場合には無限大を示すInfinityとなる
            - 剰余演算子（%）
                - 2つのオペランドである数値を徐算したあまりを求める演算子
                    - 左オペランドを右オペランドで徐算したあまりを求める
            - 大小を比べる演算子(比較演算子)
                - <
                    - 左辺は右辺より小さい
                - <=
                    - 左辺が右辺より小さい、もしくは等しい
                - >
                    - 左辺は右辺より大きい
                - >=
                    - 左辺は右辺より大きい、もしくは等しい
            - 等価演算子
                - ==
                    - 左辺と右辺が等しければtrue
                - !=
                    - 左辺と右辺が異なればtrue
                - 注意点
                    - 数値「12」と文字列「"12"」はデータの扱い上、文字列と数値となり異なるが、等価演算子においては文字列の12を数値の12に変換して処理しているため等しいものとして扱われる
            - べき乗演算子（**）
                - 2つのオペランドである数値をべき乗する演算子
                    - 左オペランドを右オペランドでべき乗した値を返す
                        - 同じ役割を持つ、Math.powメソッドが存在する
            - 厳密等価演算子
                - ===
                    - 右辺と左辺が厳密に等しい
                - !==
                    - 右辺と左辺が厳密に異なる
                - 厳密等価演算子においては数値「12」と文字列「"12"」は異なるものとして扱われるようになる。
                - 基本、理由がなければ厳密等価演算子を使用するようにする
        - 単項演算子 => 1つのオペランドを受け取る演算子
            - 単項プラス演算子（+）
                - オペランドを数値に変換する
                    - 文字列を数値に変換する
                        - 数値に変換する事ができない文字列などはNaNという特殊な値に変換される
                            - NaN => Not-a-Numberの略称
            - 単項マイナス演算子（-）
                - マイナスの数値を表す場合に利用する
            - デクリメント演算子
                - オペランドの数値を-1する演算子
            - インクリメント演算子（++）
                - オペランドの値を+1する演算子
                    - 前置インクリメント演算子
                        - 演算してから状態を評価する
                    - 後値インクリメント演算子
                        - 演算前のオペランドの状態を評価
                        - その後に演算を実行する
                        - 最終結果としてはインクリメントされる
    - 被演算子(オペランド)
        - 演算子に演算される対象の事をオペランドと呼ぶ
            - 2項演算子
                - 2つのオペランドを取る演算子の事をいう
            - 単項演算子
                - 1つのオペランドを取る演算子
    - voidという型
        - 式が値を返さない事を示すために使用するもの
            - 関数が値を返さないようにする
            - 特定の式の評価結果を無視する
        - 使い方
            - 式の計算結果
            
            ```tsx
            let result = void 0;  // undefined が代入される
            console.log(result);   // 出力: undefined
            ```
            
            - 関数での使い方
            
            ```tsx
            function doNothing() {
              void console.log("This does nothing and returns undefined.");
            }
            doNothing();
            // 出力:
            // This does nothing and returns undefined.
            ```
            
            - voidを使ったHTMLのイベントハンドラ
            
            ```tsx
            <a href="javascript:void(0)" onclick="alert('Clicked!');">Click me</a>
            ```
            
            - voidとクロージャ
            
            ```tsx
            let counter = (function() {
              let count = 0;
              return function() {
                return void count++;
              };
            })();
            
            counter();  // count は増加するが、何も返さない
            counter();  // count は再度増加するが、何も返さない
            ```
            - voidを使うと常に結果がundefinedになる
    - 総合的に知識チェック
        
        ```jsx
        console.log("表示させたい文字列");
        console.log(数値+数値);
        console.log(数値-数値);
        console.log(数値*数値);
        console.log(数値/数値);
        "8" 文字列
        8 数値
        
        let name = "mutsukura";
        console.log(name);
        console.log("name");//文字列としてのnameが出力される
        変数はデータに名前をつけた箱
        箱に名前をつけたものが変数名
        
        const 定数名　= 値
        厳密な定数は上書きできない値
        JavaScriptにおける定数は再代入禁止なもの
        const parson = {name: "ムック",age: 21}
        parson = ランタイムエラーが起きる
        parson.name = "堤竹"
        ↑
        技術面接などで聞かれやすい
        技術において似た概念が多く存在する
        概念同士の違いを理解する事が重要
        
        条件分岐
        let age = 20;
        if (age >= 18 ) {
         console.log("成人です。");
         }
        ```       
    - 繰り返し処理
        - while文
            - 複数回同内容の処理を行う際に全ての回数分処理を書くのは厳しいため条件を設定して繰り返し処理を行う
                - while (条件式){処理内容}
            - 注意点
                - 無限ループに気をつける
                    - 処理内容を定義して実行してから処理内容を適用して更新する事を忘れないようにする事が必要
        - for文
            - while文と同じく繰り返し処理を行うが条件式などの記載方法が簡潔になっている
                - for (変数の定義:条件式:変数の更新){処理内容}
            - 省略した書き方
                - 「number += 1」は「number ++」
                - 「number -= 1」を「number --」
                    - と省略して記載できる
        - 数値が3倍の場合のコード記載
        
        ```jsx
        for (let number=1;number <= 100 ; number ++) {
        
        // if文を用いて、numberが3の倍数の時に「3の倍数です」、そうでないときは数字を出力してください
        if (number %3 === 0){
            console.log("3の倍数です")
        }else{
            console.log(number)
        } 
        }
        ```
    - 配列
        - 複数の値をまとめる方法として配列という方法がある
            - [値1, 値2, 値3]と記載する事で配列にする事ができる
                - 配列は定数に代入する事ができる
                    - 配列を代入した定数は習慣上複数形にする
                - console.log(定数名)とする事で代入した定数を出力する事ができる
                    - 配列内の値を要素と呼ぶ
        - インデックス番号
            - 配列内の要素は0から始まりインデックス番号がついている
                - 配列内の要素を取得したい場合には
                    - console.log(変数名[要素のインデックス番号]); とする事で出力する事ができるようになる
        - 要素の更新と定数の再定義の違い
            - 配列を定義した定数に新たな定数を代入する事ができない、だが、要素の値を更新する事は可能
        - 配列名.length
            - 配列の数、数値を代入するもの
                - 配列に対する繰り返し処理などの際に多く活用する事が多い
    - オブジェクト
        - 複数の値を管理する方法
            - 値に対してプロパティ名をつける事で管理する
                - オブジェクトは{}で囲み
                - プロパティ名と値の間はコロン（ : ）で繋ぐ
                - プロパティ間はコンマ（,）で区切る
            - オブジェクトも定数に代入する事が可能
        - オブジェクトの値を取り出す
            - オブジェクト.プロパティ名とする事で取り出せる
        - オブジェクトの値を更新する
            - オブジェクト.プロパティ名 = 新しい値
        - オブジェクトを要素に持つ配列
            - 配列の要素がオブジェクトになっている場合
                - オブジェクトに対してインデックス番号が振られている
                    - 配列内のオブジェクトの値を取り出す
                        - 配列[インデックス番号].プロパティ名
        - オブジェクト内のプロパティにオブジェクトを用いる事ができる
            
            ```jsx
            const names = {
                name:{
                    firstName:"kouki"
                    homename:"mutskura"
                    }
                };
            
            ```
            
            - 呼び出し方法
                - 「オブジェクト名.プロパティ.プロパティ」
        - オブジェクト内のプロパティの値には配列を用いる事も可能
            
            ```jsx
            const nameList = {
                name:["kouki","toyoda","tutumitake"]
                ];
            ```
    - undefined
        - 存在しないプロパティなどを指定すると特別な値のundefinedが出力される
            - 未定義のプロパティという意味
    - 関数
        - 関数とは
            - いくつかの処理をまとめたもの
        - 関数の定義
            - const 定数名 = function(){}
                - {}の中にまとめたい処理を書く事で関数を用意できる
                    - 関数を用意する事を関数を定義するという
        - 関数の呼び出し
            - 関数を定義した際に使用した定数名を使用して関数を呼び出す
                - 定数名();
        - アロー関数
            - 通常、変数の定義はfunction()で行うがES6から() => と記載する事でも関数の定義ができる
        - 引数
            - 引数とは
                - 関数を呼び出した際に渡すデータ
                    - 括弧の中に引数名を書く事で引数を受け取る事ができる
                        - (引数名) =>
                    - 関数を呼び出す際に引数を渡す事で関数に値が渡される
                        - 定数名(引数として渡す値);
                            - 引数として渡した値が引数名に代入される
            - 複数の引数を受け取る関数
                - 受け取る引数をコンマ(,)で区切って並べることで、複数の引数を指定することができる。
                    - 左から順に第1引数、第2引数、第3引数のようになっていく
        - 戻り値
            - 関数での処理結果を戻り値として受け取る
                - 関数内でreturnと記載する
                    - 呼び出した関数に戻り値がある場合には呼び出し元が戻りにそのまま代入される
                - returnは実行されると関数の処理を終了させる性質がある
            - 戻り値の活用
                - 真偽値の取得
                    - if文の条件式をreturnすると条件式の結果として真偽値(true or false)を得る事ができる
        - スコープ
            - 定数や変数の使用できる範囲の事
                - 関数の外側で定義した定数、変数はプログラムのどこからでも使う事ができる
                - 関数の{}で定義した定数や変数は定義した関数内のみで使用できる
                    - while文などの中括弧がある構文でもスコープが作成される
            - 同じ名前の定数、変数がある場合にもスコープの範囲に応じて処理が変わる
    - クラス構文
        - クラスとは
            - 効率よくオブジェクトを作成するための設計図
                - 複数のオブジェクトを作成する際の型
            - クラスの用意
                - class クラス名
                    - クラス名は基本、大文字で開始する
            - インスタンスの作成
                - クラスを元にオブジェクトを作成する
                    - new クラス名()
                        - クラスを元に作成したオブジェクトをインスタンスと呼ぶ
                            - AnimalクラスのインスタンスをAnimalインスタンスと呼ぶ
            - コンストラクター
                - 設計図の中身
                    - インスタンスの作成時や設定内容を追加するための機能
                        - インスタンスが作成される毎に実行される
                - クラスの{}内に記載する
                    - constructor() { }
                - 作成されたインスタンスにプロパティと値を追加する方法
                    - this.プロパティ名 = 値
                        - クラスの外でインスタンス.プロパティ名とする事でクラスの外でも使用する事が可能になる
                - 引数を受け取る
                    - コンストラクタは引数を受け取る事ができる
                        - インスタンス毎に値を変えたい場合などに対応できるように
                            - 引数を()内で受け取って、{}内でthis.引数名などとして引数を受け取る
                                - インスタンスを作成する際に値を渡してコンストラクタが受け取れるようにする
            - メソッド
                - 情報（名前や年齢）を追加したのがプロパティ
                - メソッドはインスタンスの動作、振る舞いを設定する
                    - クラス内でメソッド名() { }のように記載する
                - メソッドの呼び出し方
                    - インスタンス.メソッド名()
                - インスタンス内でメソッドを使用する場合
                    - thisを使用する
                        - **this.プロパティ名**
                - メソッド内でメソッドを使う
                    - this.メソッド名()
    - クラスの継承
        - 継承とは？
            - すでに作成したクラスを元に新しいクラスを作成する事
                - 「Animalクラス」を継承して「Dogクラス」を作成する場合
                    - 「class Dog extends Animal」と書く
                - 親クラス、子クラス
                    - 親クラス
                        - 継承される元のクラス
                    - 子クラス
                        - 元のクラスを継承するクラス
            - 親クラスのメソッドを使う
                - 親クラスで定義されたメソッドは子クラス内でも使う事が可能
                    - インスタンス.メソッド名();
            - 子クラス内で独自のメソッドを作成する
                - 子クラス内では独自にメソッドを作成する事が可能
                    - 通常と同じようにメソッド名(){}と記載する
            - メソッドの戻り値
                - 関数と同じでメソッドは戻り値を受け取る事ができる
        - オーバーライド
            - 継承先の子クラスで継承元の親クラスと同名のメソッドを作成した場合はどうなるのか？
                - 子クラスで定義したメソッドに内容が上書きされる
    - ファイルの分割
        - コードの量が多くなってくると一つのファイルで管理する事が困難になるためファイルを区切りで分割する
            - ファイルを分割すると当たり前だが分割した部分のコードがなくなってしまい必要な処理がなくなってしまうためエラーになってしまう。
        - エクスポート
            - クラスの定義の後にexport default クラス名とする事でクラスをエクスポートして他のファイルに渡す事ができる
        - インポート
            - 他のファイルで定義されているクラスを使用するにはインポートをする必要があるimport クラス名 from "./ファイル名”
    - 値のエクスポート
        - クラスのみではなく、メソッドや定数など値は分割する事が可能になっている
            - エクスポート
                - export default 分割したい値
            - インポート
                - import 分割したい値 from "./ファイル名”
        - デフォルトエクスポート
            - 各ファイルにつき1回までしか使う事ができない
                - インポートの際に分割したい値が間違えていてもデフォルトとしてエクスポートされるようになっている
    - 名前付きエクスポート
        - export defaultは1回しか使用できない。
            - その他の方法として名前付きエクスポートがある
        - 名前付きエクスポート
            - export {値の名前}
                - カンマを使う事で複数の値を指定してエクスポートする事ができる
        - 名前付きエクスポートしたものをインポートする
            - import { 値の名前 } from "./ファイル名”
                - インポートの際も同様でカンマで区切る事で複数の値をインポートできる
    - 相対パス
        - importする際のファイルを指定方法
            - ファイルを指定する際にはimportをするファイルからみたexportの位置関係を示している
        - 同じディレクトリ内にいる場合
            - ./ファイル名;
                - ./で同じディレクトリという事を示す
        - 異なるディレクトにいる場合
            - 同じ親ディレクトリ内のディレクトリが違うファイルを指定する方法
                - ./ディレクトリ名/ファイル名;
                    - ./ディレクトリ名/で同じディレクトリ内のディレクトリ名を指定する
                    - その後、ファイル名を指定する
        - 1つ上の階層に戻る必要がある場合
            - ../ディレクトリ名/ファイル名;
                - 親ディレクトリ内の違うディレクトリに入っているファイルを指定したい場合
                    - ../でディレクトリの階層を戻る
                    - ディレクトリ名の指定をする
                    - ファイル名の指定
    - パッケージ
        - 他の人が作成した機能を使う事ができる
            - JavaScriptの機能を使う事でプログラムに組み込む事ができる
        - import 定数名 from “パッケージ名”;
            - 例：chalk “文字列に対して色をつける事ができパッケージ”
                
                ```jsx
                import chalk from "chalk";
                console.log(chalk.yellow(colorisyellow));
                ```
                
            - 例：readline-sync　”コンソールへの入力、入力された値をプログラムで使用する”
                - readlineSync.question(質問文)
                    - 入力された内容を定数に代入すると入力内容がそのまま代入される
                - 整数の入力を要求する時
                    - readlineSync.questionInt(質問文) 　とする
            
            ```jsx
            import readlineSync from readlinesync
            const name = readlineSync.question("名前を入力してください”)
            const age =  readlineSync.questionInt("年齢を入力してください”)
            new human (name,age) 
            ```
    - pushメソッド
        - 配列の最後に値を追加する事ができるメソッド
            - 配列名.push(配列の最後に追加したい値）
    - forEachメソッド
        - 配列内の全ての要素に対して繰り返して同じ処理を行う事
            - アロー関数が入っている
                - 引数に対して処理を行う
            - コールバック関数
                - 引数に入っている関数はコールバック関数と呼ばれる
            - 良いコードを書く
                - 関数が1列に長くなってしまうと悪い関数になってしまう
                    - {で改行すると良いコードになる
            - 配列名.forEach(アロー関数)
                - (character) => {console.log(character);}
            
            ```jsx
            characters.forEach((character) => {
            console.log(character);
            });
            ```
        - メソッドの中に関数が入る形の記載が多くなってくる
    - findメソッド
        - 配列から条件式に合う1つ目の要素を配列の中から取り出すメソッド
            - 要素を順番に検証していき1番最初に対応するものがあったらその情報を元に操作を行う。
                - コールバック関数の中身
                    - { return 条件 }　と記載する
            - 要素がオブジェクトの場合にもプロパティを指定する事でオブジェクトそのものを呼び出す事ができる
    - filterメソッド
        - 配列から条件に合う要素を全て取り出して配列にするメソッド
            - findメソッドと同様に要素がオブジェクトの場合においてもプロパティを指定する事でオブジェクトそのものを呼び出す事ができる
    - mapメソッド
        - 配列内の要素全てに対して共通する処理を行い、処理を行った要素で新しい配列を作るメソッド
            - コールバック関数の中身
                - { return 値 }
            - 配列のオブジェクト要素に対しても使うこともできる
                - return name.firstname + name.lastName
    - コールバック関数に関して
        - Webアプリ開発においてコールバック関数は頻出であり理解する事が開発において必要
            - 関数の引数に他の関数を渡している関数をコールバック関数と呼ぶ
    - JavaScriptの関数において渡せるもの
        - 文字列
        - 数値
        - 真偽値
        - 関数　→コールバック関数と呼ぶ
    - コールバック関数の流れ
        - 関数は、関数名の後ろに()をつけると呼び出される。
            - ()をつけなければ関数そのものを指す。
        ```jsx
        const printWanko = () => {
        console.log("にんじゃわんこ");
        };
        
        const call = (callback) => {
        console.log("コールバック関数を呼び出します");
        callback();
        };
        
        call(printWanko);
        
        ```  
    - 関数の流れ
        1. 関数printWankoを定義する
            - 実行されると文字列としてのにんじゃわんこを出力する
        2. 関数call**を定義する**
            - 実行されると引数として関数callbackを渡す。
                - 文字列としてのコールバック関数を呼び出しますを出力する
                - callbackに引数として渡された関数printWankoを実行する
        3. 関数callを呼び出し、引数として関数printWankoを渡す
    - コールバック関数は事前に定義した関数だけなく、直接定義する事も可能
        
        ```jsx
        () => {
          console.log("ひつじ仙人");
        }
        ```
        
        ```jsx
        // 事前に関数を定義して渡す
        ↓
        const printWanko = () => {
          console.log("にんじゃわんこ");
        };
        
        const call = (callback) => {
          console.log("コールバック関数を呼び出します。");
          callback();
        };
        
        call(printWanko);
        
        // 直接アロー関数を定義して渡す
        ↓
        // 引数で関数を定義して渡してください
        call(() => {
          console.log("ひつじ仙人");
        });
        ```
        
        - 渡す引数に応じて関数で表示される内容を変える事ができる
        - 複数の引数を渡す事もできる
            - 渡す引数の数、順番は間違えないように注意が必要
        
        ```jsx
        const call = (callback) => {
          callback("にんじゃわんこ", 14);
        };
        
        call((name,age) => {
          console.log(`${name}は${age}歳です。`);
        });
        
        ```
        

JavaScript Primer

- 第一部: 基本文法
    - コメント
        
    - 変数と宣言
        - JavaScriptで変数を宣言する方法について紹介します。変数を宣言する方法にはconst, let, varがあります。これらの動作の違いや使い分けについて紹介します。
        
        **まとめ**
        
        - 変数を宣言するキーワード
            - const
                - 再代入禁止の変数を宣言する
            - let
                - 再代入可能な変数の宣言をする
            - var
                - 再代入可能な変数だが問題が報告されている
    - 値の評価と表示
        - ブラウザでJavaScriptコードを実行する方法について紹介します。またプログラムを実行すると遭遇するエラーをどのように解決していくかを紹介します。エラーを大きく2種類に分けて、構文エラーと実行時エラーについてそれぞれの問題点と解決の糸口を紹介します。
        
        **まとめ**
        
        - JavaScriptをブラウザ上で実行する方法
            - 開発者ツールを使う方法
            - HTMLからJavaScriptを読み込む方法
                - サンプルコードを自分で動かして改変させていく
        - エラーに関して
            - JavaScriptにおいてエラーが発生した場合にはコンソールにエラー位置を教えてくれる事が大多数である
                - エラー情報を元にデバックすれば基本的には問題なく解決できるはず
                    - エラーを怖がらずにやってみる
            - エラーはJavaScriptのエラーリファレンスに多数報告されている
                - 不明な場合にはGoogleなどに同内容のエラーを載せている人がいるはず
    - データ型とリテラル
        - JavaScriptの値の種類にあたるデータ型について紹介します。データ型には大きく分けてプリミティブ型とオブジェクトがあり、それぞれのデータ型を簡単なコード例とともに紹介していきます。一部のデータ型にはリテラルというデータ型を簡単に記述するための構文が用意されており、リテラルについても合わせて紹介していきます。
        
        **まとめ**
        
        - データの型
            - 7種類のプリミティブ型とオブジェクトがある
                - プリミティブ型の真偽値、数値、BigInt、文字列、nullはリテラル表現がある
                    - プリミティブ型のデータでもプロパティアクセスができる
                - オブジェクト型のオブジェクト、配列、正規表現にはリテラル表現がある
        - リテラル
            - リテラルはデータ型の値を直接記述できる構文として定義されたもの
    - 演算子
        - JavaScriptにおける演算子について紹介します。演算子は記号で表現されるため、検索しにくいです。この章では主要な演算子をまとめて紹介しています。知らない演算子が出てきたときに読み直せばよいため、すべてを1つずつ読む必要はありません。
        
        **まとめ**
        
        - 演算子
            - よく利用する演算処理を記号などで表現したもの
                - 四則演算
                - 論理演算など
                    - 演算子には優先順位が定義されている
                    - グループ化演算子で明示可能
    - 暗黙的な型変換
        - JavaScriptの暗黙的な型変換は意図しない挙動を発生する原因の1つです。暗黙的な型変換が発生する具体的なコード例や予測が難しいことについて紹介します。逆に明示的に変換する方法についても紹介します。
        
        **まとめ**
        
        - 暗黙的な型変換
            - 暗黙的な型変換は意図しない結果となりやすいため避ける
        - 明示的な型変換
            - 比較には等価演算子（`==`）ではなく、厳密等価演算子（`===`）を利用する
            - 演算子による暗黙的な型変換より、明示的な型変換をする関数を利用する
            - 真偽値を得るには、明示的な型変換以外の方法もある
    - 関数と宣言
        - JavaScriptの関数を定義する方法について紹介します。関数やメソッドを定義する方法として関数宣言、関数式、Arrow Functionについて紹介します。また関数の引数の扱い方や関数とメソッドの違いについても紹介します。
        
        **まとめ**
        
        - 関数の宣言方法
        - 関数を値として使う方法
        - 関数式とArrow Function
        - コールバック関数
        - メソッドの定義方法
            - 基本的な関数の定義や値としての関数について
                - JSは非同期処理を扱うことが多い
                    - その場合にコールバック関数が使われる
                        - Arrow Functionを使うことで、コールバック関数を短く簡潔に書くことができる
            - JavaScriptでのメソッド
                - オブジェクトのプロパティである関数
                    - ES2015からは、メソッドを定義する構文が追加されている
        
        **まとめ**
        
        - JavaScriptの構成
            - 式
            - 文
        - 文と式
            - 文は式になれない
            - 式は文になれる
                - 文の末尾にはセミコロンをつける
                    - ブロックで終わるぶんは例外的にセミコロンをつけなくても良い
        - JavaScriptの解釈方法
            - セミコロンがない場合に自動的にセミコロンを補完する機能がある
                - この補完機能によって意図していない挙動になる事がある
    - 条件分岐
        - JavaScriptで条件分岐を扱うためのif文やswitch文を紹介します。またネストした条件分岐が読みやすさを妨げる問題をどのように解決するかについて紹介します。
        
        **まとめ**
        
        - if文 else if else条件分岐を扱う
        - 真偽値に条件式が変化する
        - 真偽値に変換するとfalseとなる値をfalsyと呼ぶ
    - ループと反復処理
        - for文やwhile文を使った反復処理について紹介します。また、同等の反復処理がArrayのメソッドでも実現できることについても紹介します。
        
        **まとめ**
        
        - for文を使った反復処理
            - **continue文やbreak文が使用可能**
        - 配列を使った反復処理
            - continue文やbreak文が使えない
            - 一時的な変数を管理する必要がない
            - 処理をコールバック関数として書く
    - オブジェクト
        - JavaScriptのObjectはオブジェクトの基礎となるものです。オブジェクトとプロパティの作成、更新、削除などの基本的な操作について紹介します。
        
        **まとめ**
        
        - Objectというビルトインオブジェクト
        - {}でオブジェクトの生成、更新を行う
        - プロパティの確認
            - in演算子
            - `Object.hasOwn`静的メソッド
            - • Optional chaining演算子（`?.`）
                - ネストしたプロパティの存在確認
                - アクセスを同時に行う記法
            - オブジェクトのインスタンスメソッドと静的メソッド
    - プロトタイプオブジェクト
        - JavaScriptにはプロトタイプオブジェクトという特殊なオブジェクトがあります。プロトタイプオブジェクトによって、メソッドなどの特性をあるオブジェクトから別のオブジェクトへと継承しています。このプロトタイプオブジェクトによる継承の動きを紹介します。
        
        **まとめ**
        
        - オブジェクトの生成時に自動生成される
            - 例：
                - toString
        - オブジェクトはほとんどがObject.prototypeを継承しているためtoStringを呼び出せる
    - 配列
        - 配列は値を順番に格納できるオブジェクトです。この配列の作成、更新、削除などの基本的な操作や実際の使い方について紹介します。また配列における破壊的なメソッドと非破壊的なメソッドの違いについても紹介します。
        
        **まとめ**
        
        - 配列　＝＞　要素を格納できるオブジェクトの1種
        - 破壊的なメソッド
        - 非破壊的なメソッド
        - 反復処理を行う高階関数（自身を返す関数）がある
        - メソッドチェーンは配列のメソッドが配列を返す事を利用している
    - 文字列
        - 文字列リテラルを使った文字列の作成から検索や置換など基本的な文字列操作について紹介します。また正規表現と組み合わせた文字列操作やタグ付きテンプレート関数を使ったテンプレート処理などについても紹介します。
    - 文字列とUnicode
        - JavaScriptが採用している文字コードであるUnicodeと関連するStringのメソッドについて紹介します。Stringのメソッドや文字列を扱う上で、UTF-16でエンコードされていることを意識する場面について紹介します。
    - ラッパーオブジェクト
        - JavaScriptのプリミティブ型の値がビルトインオブジェクトのメソッドなどを呼び出せる仕組みとしてのラッパーオブジェクトを紹介します。プリミティブ型からオブジェクトへとどのように実行時に変換されているのかを確認できます。
        
        **まとめ**
        
        - プリミティブ型はメソッド呼び出しする事ができる
            - ラッパーオブジェクトが存在している
                - 呼び出す時に自動的にラッパーオブジェクトに変換される事で呼び出し可能
        - JavaScriptは全てがオブジェクトであるわけではない
            - オブジェクトのように扱う事が可能
    - 関数とスコープ
        - スコープという変数などを参照できる範囲を決める概念を紹介します。ブロックスコープや関数スコープなどがどのような働きをしているのか、複数のスコープが重なったときにどのように変数の参照先が決まるのかなどを紹介します。また、スコープに関係する動作としてクロージャーという性質を紹介します。
        
        **まとめ**
        
        - スコープ
            - 関数
            - ブロック
            - ネスト可能
            - 1番大きなスコープ
                - グローバルスコープ
                    - 元々、大きなスコープで囲まれている
            - スコープチェーン
                - 内側のブロックチェーンから外側へ変数の定義を探していく流れの事
                - var,functionでは巻き上げが生じる
        - クロージャー
            - 静的スコープ
            - メモリ管理
    - 関数とthis
        - JavaScriptにおけるthisというキーワードの動作を紹介します。thisの参照先は条件によって解決方法が異なるため、thisの動きについてをそれぞれの条件ごとに紹介します。一見複雑なthisの動きを予測可能にするにはどうするべきかをコード例とともに紹介します。
        
        **まとめ**
        
        - this
            - 実際にthisを実行した結果の確認
                - [What is `this` value in JavaScript](https://azu.github.io/what-is-this/)で実行する事ができる
            - thisは実行環境やコンテキストによって結果が変わる可能性があり、メソッドでないものには使うべきではない
    - クラス
        - JavaScriptにおけるクラスの定義方法や継承方法を紹介します。プロトタイプベースの言語であるJavaScriptがどのように継承などを実現しているのかを紹介します。
        
        **まとめ**
        
        - プロトタイプベース
        - クラスの定義
            - クラス構文で定義する
                - プロトタイプオブジェクト
                - プロトタイプチェーン
                    - の２通りで呼び出せる
            - クラスのインスタンスにはクラスフィールドが利用可能
            - Privateクラスフフィールドを使ってアクセルを制限する事が可能
        - アクセッサプロパティはgetter,setterのメソッドでプロパティのように振る舞う
        - extendsでクラスの継承が可能
        - プロトタイプメソッドと静的メソッドはどちらも継承される
    - 例外処理
        - JavaScriptにおける例外処理について紹介します。try...catch構文の使い方やErrorオブジェクトを紹介します。またエラーが発生した際のエラー文の読み方といったデバッグ方法を紹介します。
        
        **まとめ**
        
        - try…chtch構文
            - ブロック内で発生した例外を処理する事が可能になる
            - `catch`節と`finally`節は、両方またはどちらか片方を記述する
            - `throw`文は例外を投げることができ、`Error`オブジェクトを例外として投げる
            - `Error`オブジェクトには、ECMAScript仕様や実行環境で定義されたビルトインエラーがある
            - `Error`オブジェクトには、スタックトレースが記録され、デバッグに役立てられる
        - Error Causeを使うことで、別のエラーのスタックトレースを引き継いだ新しいエラーを作成できる
    - 非同期処理:コールバック/Promise/Async Function
        - 同期処理と非同期処理の違い
            - なぜ非同期処理が重要か？
                - 非同期処理を行う方法
                    - コールバックスタイル
                    - Promise
                    - Async Function
        - 非同期処理
            - 非同期処理
                - その処理が終わる前に次の処理を評価する
                    - メインスレッドで実行でされる事もある
            - Promise
                - ES2015で導入されたビルドインプロジェクト
            - Async Function
                - 2017から導入されたビルトインオブジェクト
                    - Promiseの上に作られた構文
                        - Promiseと一緒に使う
    - Map/Set
        - データの集合を扱うビルトインオブジェクト
            - Map
            - Set
                - オブジェクトの作成方法、更新方法
                    - 実際にどのようなケースで使うのかを紹介します。
        
        **まとめ**
        
        - Map
            - キーと値の組み合わせからなるコレクションを扱うビルトインオブジェクト
                - 意図しないマッピングを避けられる
        - WeakMap
            - キーを弱い参照で持つMapと同様のビルとインオブジェクト
        - Set
            - 順序を持たないコレクションをもつビルトインオブジェクト
                - 重複する値がない事が保証されている
            - Weakset
                - 値を弱い参照で持つSetと同様のビルトインオブジェクト
    - JSON
        - JavaScriptのオブジェクトリテラルをベースに作られたデータフォーマット
            - JavaScriptからJSONの読み書きをするビルトインオブジェクトの使い方を紹介します。
        
        **まとめ**
        
        - JSのオブジェクトリテラル{}を元に作られた軽量なデータフォーマット
            - シリアライズ
                - JSONの中にはシリアライズ不可なオブジェクトもある
                    - JSON.stringifyはシリアライズ対象のtoJsonメソッドを利用する
            - デシリアライズ
    - Date
        - 日付や時刻を扱うビルトインオブジェクトのDateを紹介します。
        
        **まとめ**
        
        - Dateオブジェクトのインスタンス
            - 特定の時刻を表すビルトインオブジェクト
        - 時刻の定義
            - UTC（協定世界時）の1970年1月1日0時0分0秒を基準
                - 相対的なミリ秒として保持されている
        - DateコンストラクタでDateインスタンスを作成する事ができる
        - 単体だとユースケースでは使う事が難しい
            - ライブラリと一緒に使う事が一般的
    - Math
        - 数学的な定数や関数を提供するビルトインオブジェクト
        
        **まとめ**
        
        - Mathはコンストラクタではない
            - インスタンス化する事ができない
    - ECMAScript
        - JavaScriptの仕様であるECMAScriptについて
            - ECMAScriptの歴史や仕様策定がどのようなプロセスで行われているかを紹介します。
        
        まとめ
        
        - JS
            - ECMAScript
            - ウェブブラウザ
            - Node.js
            - WebAssembly
            - WebGL
            - WebRTC
                - 全てを知る事は難しいため知らなくてOK
                    - ただ、過程があるという事
                    - 疑問を持った時には調べる事ができるようになる事が重要
        - ECMAScriptモジュール
        JavaScriptのモジュール（ECMAScriptモジュール）について紹介します。
    - 第一部: 終わりに
        - 第2部でやる事：
            - 1部で学んだ基本文法を使ってアプリケーションを作成する
            - ブラウザ固有のAPI、ライブラリを見る
        - 文法
            - Proxy、Reflect
                - プロパティの取得、代入に対して独自の動作を定義する事ができる
        - 調べ方
            - APIについて
                - MDN Web Docsというリファレンスに大部分が載っている
                    - 実質的な公式レファレンス
- 第2部
    - アプリケーション開発の準備
        - Node.jsのLTS版をインストールした
        - npmとnpxでモジュールのインストールと実行をした
        - `@js-primer/local-server`モジュールを使ってローカルサーバーを起動して終了した
    - Ajax通信
        - エントリーポイントの作成
            - このセクションでは、エントリーポイントとなるHTMLを作成
                - JavaScriptモジュールのエントリーポイントとなるJavaScriptファイルを読み込む
            - `ajaxapp`という名前のプロジェクトディレクトリを作成した
            - エントリーポイントとなる`index.html`を作成した
            - JavaScriptのエントリーポイントとなる`index.js`を作成し`index.html`から読み込んだ
            - ローカルサーバーを使ってブラウザで`index.html`を表示した
            - `index.js`からコンソールに出力されたログを確認した
            - JavaScriptからHTMLドキュメントを操作するDOMについて学んだ
        - HTTP
            - [Fetch API](https://developer.mozilla.org/ja/docs/Web/API/Fetch_API)を使ってHTTPリクエストを送った
            - GitHubのAPIから取得したユーザー情報のJSONオブジェクトをコンソールに出力した
            - Fetch APIの呼び出しに対するエラーハンドリングを行った
            - `fetchUserInfo`関数を宣言し、ボタンのクリックイベントで呼び出した
        - データを表示する
            - [テンプレートリテラル](https://jsprimer.net/basic/string/#create)を使ってHTML文字列を組み立てた
            - `innerHTML`プロパティを使ってHTML文字列をDOMに追加した
            - [タグつきテンプレート関数](https://jsprimer.net/basic/string/#tagged-template-function)を使ってHTML文字列をエスケープした
            - `fetchUserInfo`関数を呼び出し、HTMLにユーザー情報が表示されることを確認した
        - Promiseを活用する
            - HTMLの組み立てと表示の処理を`createView`関数と`displayView`関数に分離した
            - `main`関数を宣言し、`fetchUserInfo`関数が返すPromiseのエラーハンドリングを行った
            - Promiseチェーンを使って`fetchUserInfo`関数をリファクタリングした
            - [Async Function](https://jsprimer.net/basic/async/#async-function) を使って`main`関数をリファクタリングした
            - `index.html`に`<input>`タグを追加し、`getUserId`関数でユーザーIDを取得した
    - Node.jsでCLIツールを作成する
        - Hello world
            - `nodecli`ディレクトリを作成した
            - `nodecli/main.js`ファイルを作成した
            - `node`コマンドで`nodecli/main.js`を実行し、標準出力にログが出力されるのを確認した
            - `npm init --yes`コマンドで`nodecli/package.json`ファイルを作成した
            - グローバルオブジェクトについて、ウェブブラウザとNode.jsで実行環境による違いがあることを理解した
        - コマンドライン引数を設定する
            - `process.argv`配列に`node`コマンドのコマンドライン引数が格納されていることを確認した
            - ECMAScriptモジュールを使ってパッケージを読み込めることを確認した
            - `node:util`モジュールの`parseArgs`関数を使ってコマンドライン引数をパースできることを確認した
            - コマンドライン引数で渡されたファイルパスを取得してコンソールに出力できた
        - ファイルを読み込む
            - `node:fs/promises`モジュールの`readFile`関数を使ってファイルを読み込んだ
            - UTF-8形式のファイルの中身をコンソールに出力した
            - `readFile`関数の呼び出しにエラーハンドリング処理を記述した
        - MarkDownファイルをHTMLへ変換する
            - markedパッケージを使ってMarkdown文字列をHTML文字列に変換した
            - コマンドライン引数でmarkedの変換オプションを設定した
            - `-gfm`フラグを使って、Markdownの変換結果が変わることを確認した
        - ユニットテストを記述する
            - Markdownの変換処理をECMAScriptモジュールとして`md2html.js`に切り出し、`main.js`から読み込んだ
            - `npm test`コマンドで`node --test`が実行できることを確認した
            - `md2html`関数のユニットテストを作成し、テストの実行結果を確認した
    - Todoアプリケーションを作る
        - エントリーポイント
            - `todoapp`という名前のプロジェクトディレクトリを作成した
            - エントリーポイントとなる`index.html`を作成した
            - JavaScriptのエントリーポイントとなる`index.js`を作成し`index.html`から読み込んだ
            - ローカルサーバーを使って`index.html`を表示した
            - `src/App.js`を作成し、`index.js`から`import`文で読み込めるのを確認した
        - アプリケーションの構成要素
            - 実装するTodoアプリの構成要素を理解した
            - HTML、CSS、JavaScriptの役割の違いを理解した
            - Todoアプリの見た目をHTMLとCSSで定義した
        - Todoアイテムの追加を実装する
            
            チェクリスト
            
            - フォームの送信を`submit`イベントで受け取り、入力内容を確認した
            - HTML文字列からHTML要素を作成する`html-util.js`を実装した
            - フォームからTodoアイテムを追加した
            - Todoアイテムの追加に合わせてTodoアイテム数を更新した
            
            このセクションで、TodoアプリにTodoアイテムを追加する機能が実装できました。
            
            - Todoアイテムを追加できる
            
            Todoアプリに実装する残りの機能は次のとおりです。
            
            - Todoアイテムの完了状態を更新できる
            - Todoアイテムを削除できる
        - イベントとモデル
            - 直接DOMを更新する問題について理解した
            - `EventEmitter`クラスでイベントの仕組みを実装した
            - TodoリストとTodoアイテムをモデルとして実装した
            - `TodoListModel`を`EventEmitter`クラスを継承して実装した
            - Todoアイテムの追加の機能をモデルを使ってリファクタリングした
        - Todoアイテムの更新と削除を実装する
            - Todoアイテムの完了状態として`<input type="checkbox">`を表示に追加した
            - チェックボックスが更新されたときの`change`イベントのリスナー関数でTodoアイテムを更新した
            - Todoアイテムを削除するボタンとして`<button class="delete">x</button>`を表示に追加した
            - 削除ボタンの`click`イベントのリスナー関数でTodoアイテムを削除した
            - Todoアイテムの追加、更新、削除の機能が動作するのを確認した
            
            このセクションでTodoアプリに必要な要件が実装できました。
            
            - Todoアイテムを追加できる
            - Todoアイテムの完了状態を更新できる
            - Todoアイテムを削除できる
        - Todoアプリケーションのリファクタリング
            - Appから表示に関する処理をViewコンポーネントに分割した
            - Todoアプリの機能と対応するリスナー関数を`App`クラスのメソッドへ移動した
            - Todoアプリを完成させた
    - このTodoアプリケーションで実装できていない事
        - 空の投稿を防ぐ事
        - ライフサイクル処理
            - on関数関連
    - アプリケーションのまとめ
        - JSで作られる代表的なアプリケーションとしてTodoアプリがある
            - 今回はライブラリを使用しない
                - 実務では確実にライブラリを使う
                    - しかし、ライブラリも基礎の上に立つものである事を忘れないようにする
