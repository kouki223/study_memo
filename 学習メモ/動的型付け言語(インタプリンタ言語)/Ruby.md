- 学習ソース
    https://qiita.com/oekazuma/items/6daa19248353c6a81146
    https://prog-8.com/dashboard
    ドキュメント
    ・プロを目指す人のためのRuby入門
    ![Ruby入門書](/Public/image.png)
- Rubyの概要
    - Rubyという言葉の出自
        - 元々、6月にPealという言語が登場していた
            - 6月の誕生石
                - 真珠（Pearl）
        - その後、7月に登場した言語をPealに続く言語という意味でRubyにした
            - 7月の誕生石
                - **ルビー**
    - まつもとゆきひろ氏が開発したオブジェクト指向スクリプト言語
        - オブジェクト指向とは？
            - データや処理、クラスなどを一つのオブジェクト（もの）として扱う事
                - モノとモノの関係性でプログラムを表現する
            - オブジェクト指向でプログラムする事で現実世界で作っているような感覚と近い
                - 現実世界の抽象化と似ている
        - スクリプト言語とは？
            - 比較的簡易的に記述や実行をする事ができる言語の事を言う。
                - 理由：
                    - 記述形式が自然言語に似ていると言う事
    - 動的型付け言語と静的型付け言語
        - 変数の型をチェックするタイミングが異なる
            - 動的型付け言語　＝＞　プログラムの実行時に型をチェックする
                - インタプリンタ型言語
                    - プログラムを一行ずつ変換して実行する
                        - Ruby、JavaScript、Phython など
                            - スクリプト言語に多い
            - 静的型付け言語　＝＞　コンパイル時に型をチェックする
                - コンパイルが必要な言語
                    - ソースコードを一括で機械語に変換してから実行される
                        - すぐに実行できないけど、コンパイルできれば動作がスムーズな言語
                - 最近の流れ
                    - 最近ではコンパイルが必要な言語が使用される事が多い
                        - ２０年前とかはコンパイル自体に変換する事自体に時間がかかっていた
                            - 今はCPU性能などが改良されておりコンパイルの時間が改善された
                                - 変換後の動作がスムーズなコンパイル言語が選択される
                - 初心者には難しい言語
                    - 型という概念が出てくる
                        - 静的な型付け言語特有の概念などが出てくる
        - インタプリンタ
            - コンパイルが不要な言語
                - ソースコードを一行づつ実行する
            - すぐに実行できるという利点がある
                - 例：Ruby、JavaScript
                    - 人気だけど少し下がってきている
                        - コンパイル言語がパフォーマンスの観点から選択される事がある
        - 高水準言語
            - RubyやPhyton
                - 人間がわかるプログラミング言語からバイナリー（機械語）に変換する事でコンピューターに指令を実行する事ができる
    - Webアプリケーションのシステムを作るために使われる
        - Webアプリケーションとは？
            - ブラウザ上で動くアプリケーション
                - ブラウザ環境があればどこでも実行できる
        - Webアプリにおけるシステムとは？
            - 現実を抽象化してWebアプリを用いてシステムに落とし込んだもの
        - ネイティブアプリ
            - ネイティブな環境（限定された環境）でのみ動作するアプリ
                - OSに依存する場合
                    - Linux(mac) or windows
    - サーバー側で動作する言語
        - サーバーとは？
            - 常に動作しているコンピューター
                - クライアントの要求に365日いつでも対応してくれる
        - サーバーサイドで行なっている動作
            - フロント
                - メニューの選択画面が表示される
                    - クライアントがメニューの選択を行う
                - フロントがAPIを介してデータベース層へリクエスト内容を送る
            - バックエンド
                - フロントからの情報を受け取る
                    - リクエスト内容を元にデータを管理してリクエスト内容に応じたレスポンス内容を返す
                - 例えば、メニューシステムであれば
                    - 誰が何のメニューを選択したか？のデータを管理する
                        - サーバー内で動作するプログラムである
    - ブラウザ側で動作する言語
        - マークアップ言語
            - HTML
            - CSS
    - Rubyの処理系
        - Webアプリケーションのフレームワーク
            - Rails
        - MRI（Matz`Ruby Implementation）
            - まつもとゆきひろ氏によって開発された処理系
        - Java
            - JRuby
        - GraalVM
            - TruffleRuby
        - Rust
            - Artichoke
        - RubyスクリプトをJavaScriptにコンパイルする
            - Opal
        - 組み込みシステム向け
            - mruby
    - Ruby3.0
        - MJITによる実行パフォーマンスの改善（Ruby 2.0に比べて約3倍高速化した）
        - Ractor、Fiber Schedulerと呼ばれる新しい並行・並列処理機構の導入
        - RBSとTypeProfによる静的解析基盤の構築
    - Rubyのインストール方法
        - Rubyのインストール方法は多岐にわたる
            - 時代に合わせてインストールする
                - 標準でインストールされているものは避ける
                    - Gemの関係
    - プレーンテキストを実行する
        - プレーンテキストにRubyのコードを記載するとターミナルでRuby ファイルパスとする事で実行されて処理結果が返ってくる
            - インタプリンタ言語である
        - 注意点：
            - UTF-8で記載されているか？
            - プレーンテキストで記載されているか？
            - 英数字、記号が全角になっていないか？
        - 他のファイルに記載されているRubyコードの実行方法
            - ワンライナー
                - ファイルの1行目に#!で始まる特別なコメントを入れる
            - shebang（シバン、シェバン）
    - Rubyにおける型の概念
        - Rubyに型の概念があるか？
            - 型の概念はない
                - 型の制限などをする事もできない
                
                ↓
                
            - しっかり型の概念を整理
                - 公式ドキュメント
                    - 変数・定数・仮引数・ブロックパラメーターには型の制限がない
                    - しかし、オブジェクトが属すクラスはデータ型を表す
                        - 文字列オブジェクトは [**String**](https://docs.ruby-lang.org/ja/3.0/class/String.html) 型
                        - 浮動小数点数オブジェクトは [**Float**](https://docs.ruby-lang.org/ja/3.0/class/Float.html) 型
                            - クラスの継承という観点から見た時に浮動小数点数は Float 型であると同時に数値という概念で抽象化した時に [**Numeric**](https://docs.ruby-lang.org/ja/3.0/class/Numeric.html) 型とも言う事ができる
                        - クラスに include されているモジュール
                            - データを特徴づけるものであり、データ型を表している
                        - [**Comparable**](https://docs.ruby-lang.org/ja/3.0/class/Comparable.html) モジュールが include されているクラス
                            - 大小比較に基づくさまざまなメソッドが使える事からComparable 型
                        - Array、[**Enumerator**](https://docs.ruby-lang.org/ja/3.0/class/Enumerator.html)、[**Hash**](https://docs.ruby-lang.org/ja/3.0/class/Hash.html) といったクラスのインスタンスは [**Enumerable**](https://docs.ruby-lang.org/ja/3.0/class/Enumerable.html) 型
                            - 繰り返し処理を行うクラスのmix-in
                - Ruby 2.7 で試験的に導入された case/in
                    - オブジェクトのパターン
                        - 1種の型であると考える事もできる
            - オブジェクトの渡せるデータという観点で考えると型の概念はないと考えるが、クラス単位で型の概念という部分を整理すると型の概念はデータ型として存在する
                - ただ、データの型に応じた制限などをかける事はできない
                    - あくまで概念の部分
- Rubyの仕様
    - 分の区切り
        - 改行
            - 基本的にはRubyでは改行を入れると文の終わりになる
            - ヒアドキュメント（行指向文字列リテラル）
                - 文字列
                    - 途中で改行する事ができる
                        - 複数行になる文字列は改行する方が良い
                        - 特に長い文字列にはヒアドキュメントを使う
                    - 変数展開が有効になる
                        - 識別子をシングルクウォーテーションで囲むと無効になる
                    - 改行文字が有効
                        - 識別子をシングルクウォーテーションで囲むと無効になる
                    - 識別子
                        - 一つの式としてみなされる
                            - メソッドの引数やメソッドを呼び出す事ができたりする
                - 構文：
                    
                    <<識別子
                    1行目
                    2行目
                    3行目
                    識別子
                    
                    - 識別子は自由につける事ができる
                        - 慣習としてHTMLやTEXTのように大文字でつける事が多い
                    - 識別子の前に入れる事で起きる影響
                        - -を入れると最後の識別子を勝手にインデントしてくれる
                        - ~を入れると内部の文字列をインデントしても先頭の空白部分が無視されるようになる
                        - 行頭を/で指定すると~を入れつつ行頭の空白を指定する事ができる
            - 変数展開をする例：
                
                ```ruby
                name = 'Alice'
                a = <<TEXT
                ようこそ、#{name}さん！
                以下のメッセージをご覧ください。
                TEXT
                puts a
                #=> ようこそ、Aliceさん！
                # 以下のメッセージをご覧ください。
                ```
                
            - ヒアドキュメントを式として扱う
                
                ```ruby
                # ヒアドキュメントを直接引数として渡す（prependは渡された文字列を先頭に追加するメソッド）
                a = 'Ruby'
                a.prepend(<<TEXT)
                Java
                Python
                TEXT
                puts a
                #=> Java
                # Python
                # Ruby
                # ヒアドキュメントで作成した文字列に対して、直接upcaseメソッドを呼び出す
                # (upcaseは文字列をすべて大文字にするメソッド)
                b = <<TEXT.upcase
                Hello,
                Good-bye.
                TEXT
                puts b
                #=> HELLO,
                # GOOD-BYE.
                # ヒアドキュメントを2つ同時に使って配列を作る（配列については第4章で詳しく説明します）
                c = [<<TEXT1, <<TEXT2]
                Alice
                Bob
                TEXT1
                Matz
                Jnchito
                TEXT2
                # 0番目の要素にはTEXT1の内容が入る
                puts c[0]
                #=> Alice
                # Bob
                # 1番目の要素にはTEXT2の内容が入る
                puts c[1]
                #=> Matz
                # Jnchito
                ```   
        - 区切り文字
            - 明示的に文の区切りをつける
                - セミコロン　;
                - バックスラッシュ \
            - 区切り文字として使うことが出来る記号
                - ？
                - ^
        - 文と式
            - Rubyにおいては他の言語では文と見なされるようなものでも式と判断されるものがある
                - 文と式の定義
                    - 文
                        - 値を返さず、変数に代入しようとすると構文エラーになるもの
                    - 式
                        - 値を返し、結果を変数に代入できるもの
                            - if文やメソッドは式として扱う
                                - 変数への代入可、自身が戻り値を持っている
    - クラスとインスタンスの概念
        - クラスに例えばどういうものがあるか？
          - 食べ物クラス
          - 飲み物クラス
          - 生物クラス
          - 動物クラス
          - 植物クラス
          - 哺乳類クラス
          - 爬虫類クラス
          - 人間クラス
          - イルカクラス
          - 男性クラス
          - 女性クラス
        - インスタントにはどのようなものがあるのか？
            - 豊田インスタス
            - 六倉インスタンス
        - なぜクラスは作るのか？
            - 可読性を上げる
                - 概念に対して、クラス名をつける事で読み手がわかりやすくなる
            - 変更しやすい => 修正箇所が少ない => 共通の処理がある
                - クラスは、共通のものを共通として扱うための仕組みである
        - 概念について
            - 生物
                - 動物, 植物(生物の下概念)
                    - 動物
                        - 昆虫, 哺乳類, 爬虫類(動物の下位概念)
                            - 哺乳類
                                - 人間, いるか, 猫, 犬(哺乳類の下位概念)
    - プログラムの本質・概念（上位概念・下位概念）
        - メソッド
            - 足し算, 引き算, 出力
        - データ
            - インスタンス, 変数, クラス
                - 文字列, 数値
        - プログラム本質　＝＞　処理とデータ
            - システムとは？
                - プログラムを作ってシステム
                    - システム(上位概念)
                        - 料理注文システム, 会計システム, ゲームシステム
                            - システムとは、現実を抽象化したものである
        - 抽象化とは？(抽象化 <=> 具体化)
            - 抽象
                - 生物, 哺乳類
            - 具体
                - 猫, 虫, 人間  (抽象化)=> 動物<=>植物 => 動物とは動くもの
            - 抽象化とは
                - 共通する同じ要素を抽出したもの
            - 具体
                - 六倉, 僕 => 人間であること, 男性であること
        - システムとは、現実を抽象化したものである
            - ゲームというものの中の概念
                - ユーザがいる
                    - ユーザとは => システムにおける人間
                - ユーザはどのような情報を入れる？ => 名前, 年齢, 性別, メールアドレス
                    - 名前, 年齢, 性別, メールアドレス => 人間を構成する共通の要素
                        - ユーザとは => 人間を抽象化したものである
            - 人間
                - 肌の色
                - 遺伝子
                - 思想
                - 名前
                - 年齢
                - 性別
                - メールアドレス
                    - => システムとは現実を抽象化したもの
        - 業務システム(会計システム)
            - 会計システム => 現実における会計という一連の流れを抽象化したもの
        - 会計システム
            - 金額, 誰の経費？
    - 文字列の扱い
        - 文字列は全てstringクラスのオブジェクトになる
            - 文字列の指定方法
                - ダブルクウォーテーション or シングルクウォーテーションだけではない
        - %記法
            - %記法というものがある
                - 文字列内でダブルクウォーテーションをそのまま表示するにはエスケープする事が必要になる
                - もし、%記法を使っている場合にはエスケープする必要がなくなる
            - ダブルクウォーテーションと判定される構文
                - %Q ! 表示したい文字列 !
                - % ! 表示したい文字列 !
            - シングルクウォーテーションと判定される構文
                - %q ! 表示したい文字列 !
        - %記法を使うプログラム
        
        ```ruby
        # %q! !はシングルクオートで囲んだことと同じになる
        puts %q!He said, "Don't speak."! #=> He said, "Don't speak."
        # %Q! !はダブルクオートで囲んだことと同じになる（改行文字や式展開が使える）
        something = "Hello."
        puts %Q!He said, "#{something}"! #=> He said, "Hello."
        # %! !もダブルクオートで囲んだことと同じになる
        something = "Bye."
        puts %!He said, "#{something}"! #=> He said, "Bye."
        ```
        
        - %記法を使わない記載方法
        
        ```ruby
        puts 'He said, "Don\'t speak."' #=> He said, "Don't speak."
        something = "Hello."
        puts "He said, \"#{something}\"" #=> He said, "Hello."
        something = "Bye."
        puts "He said, \"#{something}\"" #=> He said, "Bye."
        ```   
    - 数値
        - Rubyにおける数値の表現
            - 10、1.5、-3、-4.75など、Rubyでは人間が自然に理解しやすい形式で数値を書くことができる
                
                ```ruby
                # 正の整数
                10
                # 小数
                1.5
                # 負の整数
                -3
                # 負の小数
                -4.75
                ```
                
                - 数値には_を含めることができます。_は無視される
                    - 大きな数の区切り文字として使うと便利です。
                
                ```ruby
                1_000_000_000 #=> 1000000000
                ```
                
        - 数値クラス
            - Numericクラスのサブクラス
                - 整数
                    - Integerクラス
                - 小数
                    - Floatクラス
                - 有理数
                    - Rationalクラス
                - 複素数
                    - Complexクラス
                
                ```ruby
                10.class #=> Integer
                1.5.class #=> Float
                
                # 有理数リテラルを使う（3rが有理数リテラル）
                r = 2 / 3r
                r #=> (2/3)
                r.class #=> Rational
                
                # 文字列から有理数に変換する
                r = '2/3'.to_r
                r #=> (2/3)
                r.class #=> Rational
                # 複素数リテラルを使う（0.5iが複素数リテラル）
                c = 0.3 - 0.5i
                c #=> (0.3-0.5i)
                c.class #=> Complex
                # 文字列から複素数に変換する
                c = '0.3-0.5i'.to_c
                c #=> (0.3-0.5i)
                c.class #=> Complex
                ```              
    - 出力
        - 文字列の出力
            - 文字列の出力
                - puts ”出力したい内容”
                    - 出力したい内容の前には半角スペースを入れる必要がある
                        - ダブルクウォーテーションで囲むことで出力できる
                            - puts "john"
                                - john（文字列としての出力）
        - 数値の出力
            - ダブルクウォーテーションで囲まずに出力する
        - 変数の出力（変数展開）
            - john（name変数に代入された文字列の出力）
            - 変数を文字列に含める
                - ダブルクウォーテーションで囲まれた文字列式、コマンド文字列、正規表現の中では＃｛式｝という形式で埋め込む事ができる
                    
                    ```ruby
                    puts "kouki"
                    ```
                    
                - 式展開の注意点
                    - シングルクウォーテーションの場合には式展開が行われない
    - バックスラッシュ記法
        - 改行文字（\n）
            - 文字列に埋め込む場合にはダブルクウォーテーションで囲む
        - \r（キャリッジリターン）
        - \t（タブ文字）
        - 変数展開などの機能を変数の前などの機能を使う前でバックスラッシュを記載する事で効果を取り消す事ができる
        
        ```ruby
        puts 'He said, "Don\'t speak."' #=> He said, "Don't speak."
        puts "He said, \"Don't speak.\"" #=> He said, "Don't speak."
        ```       
    - データの型
        - プログラムはデータを型で判別する
            - 数値
            - 文字列
            - 出力
        - 文字列や数値などの違い
            - 記載方法によってコンピューターは認識の仕方が変わる
                - "1"＝文字列
                - 1＝数値
                    - puts "1" + "1" = "11"
                        - 文字列の連結
                    - puts 1 + 1 = 2
                        - 数値の計算
    - 計算
        - 数値の計算
            - 足し算は　＋
                - puts 2 + 2　出力内容　４
            - 引き算は　ー
            - 掛け算は　＊（アスタリクス）
            - 割り算の計算は　/
            - あまりの計算　％
        - 文字列の計算（文字列の連結）
            - 文字列の間に＋を入れることで連結されて一つの文字列になる。
                - 連結の際には文字列と数値の場合で変わることに注意する
        - 変数の計算
            - 文字列の入った変数の連結
            - 変数は文字列と同様に扱うことができ、通常の文字列の連結と同様に変数連結することができる
                
                name = "kouki"
                
                puts name + "mutsukura"
                kouki mutsukura
                
            - 変数と変数の連結
                - last name = "mutsukura"
                - puts name + last name
                - kouki mutsukura
            - 数値の入った変数の連結なども同様に行うことができる
                - 同じ変数が入っているコードは省略する事ができる
                    - X ±= 10（足し算）
                    - X＊= 10（掛け算）
                    - X\= 10（割り算）
                    - X％＝ 10（あまり算)
            - 変数の前に-をつけると正と負を反転する事ができる
            
            ```ruby
            n = 1
            -n #=> -1
            ```
            
            - 整数同士の割り算
                - 整数同士の割り算は整数になる点に注意してください。小数点以下は切り捨てられます
            
            ```ruby
            # 0.5ではなく0になる
            1 / 2 #=> 0
            ```
            
            - 小数点以下の値が必要な場合は、どちらかの値に小数点の.0を付けます。
            
            ```ruby
            1.0 / 2 #=> 0.5
            1 / 2.0 #=> 0.5
            ```
            
            - 変数に整数が入っている場合にはto_fメソッドを呼ぶ事で整数から少数に変更する事ができる
            
            ```ruby
            n = 1
            n.to_f #=> 1.0
            n.to_f / 2 #=> 0.5
            ```            
    - 変数
        - データを入れる箱のようなもの
        ```ruby
         number = 7
         name = "太郎"
         puts number + 3
         puts 7 + 3
         puts "佐藤" + name      
         ```
        - 変数は何の為に存在しているのか？
            - 汎用化できる
                - 使い回す事ができる
                    - プログラムの可読性が高くなる
                        - 変数 = 10
                        - 変数 += 5
                        - 変数 = 変数 + 5
                    - 例として、フォームで入力されたデータ
                        - 太郎, 花子
                            - 入力されたデータに対してnameという名前をつける
                                - データに対して名前をつける事ですぐにデータの概念がわかる
                    - 例えば、3.141519という円周率のデータがあった場合
                        - pie = 3.141519と変数で定義し、puts pieとする事でどんなデータか一目でわかるようになる
                - 変更しやすい　＝＞　変更箇所が少なくなる
                    - 例えば、消費税の計算システムがあった場合に
                        - 料金 = もの値段 * 1.1
                        - 料金 = もの値段 * 1.1
                        - 料金 = もの値段 * 1.1
                        - 料金 = もの値段 * 1.1
                            - 消費税率が1.1 から 1.15に変更になった場合
                    - 消費税率をtaxと定義して tax = 1.1 としておけば
                        - 料金 = もの値段 * tax とする事で共通して使う事ができるようになる
                - 可読性が高かくなる
                    - 変数を概念を掴んだ内容にする事で可読性が高くなる
        - 変数の命名時の注意点
            - 名前をつける際にどのような点が大事か？
                - 英単語で名前をつける
                - 概念を捉えた名前にする & 適切な名前
                - ２語以上の場合にはアンダーバーを使う
                - 数字で始まる変数やローマ字での変数、日本語の変数は推奨されない
            - 69kg, 75kg, 30kg というデータがあった場合
                - human or weight　どちらが適切か？
                    - humanWeightという名前をつけると概念を掴んだ＋適切な名前になる
        - 変数の優先順位
            - Rubyは上から下に要素が影響していく。
                - 変数を新しく下に書いた場合には上の変数は更新される。
                - 変更される前の変数はそのままで上から順に出力される
        - 擬似変数
            - nil,true,false
            -  self ： オブジェクト自身（第7章で詳しく説明）
            - __FILE__： 現在のソースファイル名
            - __LINE__： 現在のソースファイル中の行番号
            - __ENCODING__： 現在のソースファイルのスクリプトエンコーディング
                - 擬似変数は値を読み出す事ができるが、値を代入すると構文エラーになる
    - 参照の概念
        - Rubyの変数にはオブジェクトそのものではなくオブジェクトへの参照が格納されている
            - 変数を他の値に代入する、メソッドの引数に渡す
                - これは、元の変数の参照を指定していることになる
                    - object_idメソッドを使うとわかる
        - 参照の概念を理解する事が重要になる
            - 文字列や配列、ハッシュ　＝＞　ミュータブルな値
                - 同一のオブジェクトを参照しているか？
                - 異なるオブジェクトを参照しているか？
                    - 思いがけないバグを生み出す可能性がある
    - 演算子
        - 比較演算子
            - 「a < b」は、aの方がbより小さいときtrue, 大きいときfalse
            - 「a <= b」とすると、aの方がbより小さいまたは等しい時にtrueとなる
            - 「a == b」はaとbが等しければtrue、等しくなければfalse
            - 「a != b」はaとbが等しくなければtrue、ひとしければfalse
        - ビット演算子
            - 整数値をビット演算する事ができる
                - 整数値の2進表現に対応したビット列に関する演算
                    - & ： ビットごとの論理積（AND）
                    - ¦ ： ビットごとの論理和（OR）
                    - ^ ： ビットごとの排他的論理和（XOR）
                    - >> ： 右ビットシフト
                    - << ： 左ビットシフト
                    - ~ ： ビットごとの論理反転（NOT）
    - バイト値の具体的な値
        - bytesメソッドを使うと文字列のバイト値が配列で返る（配列は第4章で詳しく説明します）
            - 'a'.bytes #=> [97]
            - 'b'.bytes #=> [98]
            - 'A'.bytes #=> [65]
            - 'abc'.bytes #=> [97, 98, 99]
            - 'あ'.bytes #=> [227, 129, 130]
    - コメントアウト
        - コメントの書き方
            - ＃を行の先頭にかいてメモを残すようにする
    - 条件分岐
        - if文
            - if文とは？
                - 要求・データに応じて処理を分ける事を条件分岐と呼ぶ
                    - ifの後ろに条件をかいてif文のあとの条件が成り立つ場合、処理を実行する（trueとして判定する）
                        - if end score = 94
                        if score > 80
                        　puts “よくできました” 
                        end 
                        = よくできました 
                         score = 38 ＝＞ 何も出力されない
                - 真偽値
                    - 条件式は真偽値として成り立つ場合に（TRUE）成り立たない場合（false）に置き換わる
                        - tureの場合には処理は実行されてfalseの場合には処理は実行されないがelseを使う事でfalseだった場合の処理を定義できる
                            - elseはifがfalseだった場合に処理が実行される
                                - if score = 100 puts "Good" else "Bad" end
                                    - elseにも合致する結果がない場合にはfalseではなく、nilが帰る
                        - 条件分岐はelsifを使うことで追加する事ができる
                            - もし〇〇だった場合には００を行い（if＝true）、そうでない場合には〇〇を行う（elsif＝true）。そうでもなければ〇〇を行う（else）。
                            - elsifは好きなだけ並べることができる
                                - 比較演算子と呼ばれる大小比較の記号で真偽値の判定をする
                                a＜c aの方がcより小さい時ture
                                a＞c aの方がcより大きい時ture
                                ＜＝or＞＝　小さいまたは等しい＆大きいまたは等しい　→ どちらの場合にもtureになる
                                ＝＝　等しい時にture
                                ！＝　異なる時にture
                - 複数の条件を組み合わせる方法（＆＆　｜｜）
                    - かつ（＆＆）
                        - 条件1＆＆条件2 （条件1、条件2どちらも成立する場合にtrueになる）
                    - または（｜｜）
                        - 条件1 ｜｜条件2（条件1、条件2どちらかがtrueの場合にはtrue）
            - 例題
                - 遊園地のシステム際に、体重制限 or 身長制限
                    - if humanWeight > 規定体重
                - 真偽値を返す
                    - 真: true　偽: false
                        - trueであれば実行する
                        - falseであれば実行しない
                            - if a < b
                            - if a < 10 && a > 1
                            - if a > b
                            - if a == b
                - else / elsif
                    - 条件を新しく追加する
                        - elsif (条件)
                            - 最初のifに当てまらない実行する
                            - elsifにも当てはまらない場合
                            - 何にも当てはらない場合
                    
                    ```ruby
                    - score = 92
                        
                           if score > 8０
                        
                        puts “よくできました”
                        
                           end
                    ```
                    
            - if文は自身の計算結果を返り値としてもつ
                - if文自身の計算結果を返り値として持つためputsを使って出力する必要がない
            - 変数にif文を代入する
                - if文は計算結果を返すため変数へ代入する事で変数を呼び出す事でif文を実行する事ができる
            - 修飾子としてのif
                - Rubyにおけるifは修飾子として文の後ろに置く事ができる
                    - 後値ifと呼ばれる
                        - 条件式の後ろにif文を記載して条件分岐させる
                - 例：
                    - 毎月1日だけ、ポイントが５倍になるという条件のプログラム例
                        
                        ```ruby
                        point = 7
                        day = 1
                        # 1日であればポイント5倍
                        if day == 1
                         point *= 5
                        end
                        point #=> 35
                        ```
                        
                        ↑
                        
                        これを後置ifを使うと
                        
                        ```ruby
                        point = 7
                        day = 1
                        # 1日であればポイント5倍（if修飾子を利用）
                        point *= 5 if day == 1
                        point #=> 35
                        ```
                        
                        このように短縮する事ができる
                        
            - thenを使ったif文
                - 使用頻度は少ないがthenを使ったif文の後ろにはthenを使える
                    
                    ```ruby
                    if 条件A then
                     # 条件Aが真だった場合の処理
                    elsif 条件B then
                     # （条件Aが偽で）条件Bが真だった場合の処理
                    else
                     # それ以外の条件の処理
                    end
                    ```
                    
                    実際のコード
                    
                    ```ruby
                    country = 'italy'
                    if country == 'japan' then 'こんにちは'
                    elsif country == 'us' then 'Hello'
                    elsif country == 'italy' then 'Ciao'
                    else '???'
                    end
                    #=> "Ciao"
                    ```
                    
            - FizzBuzz問題
                - FizzBuzzプログラムを作成する
                    - 3で割り切れる数値を引数に渡すと、“Fizz”を返す。
                    - 5で割り切れる数値を引数に渡すと、“Buzz”を返す。
                    - 15で割り切れる数値を引数に渡すと、“Fizz Buzz”を返す。
                    - それ以外の数値はその数値を文字列に変えて返す
                        
                        **完成物**
                        
                        ↓
                        
                        [fizz_buzz.rb](attachment:78a53eb2-f50b-4fb7-89e4-b0a3fa83cec1:fizz_buzz.rb)
                        
            - 真偽値と条件分岐
                - Rubyの式評価のタイミング
                    - &&や||の戻り値と評価のタイミング
                        - 戻り値
                            - 式全体の戻り値は必ずtrue falseになるとは限らない
                        - 式の評価のタイミング
                            - Rubyは式全体が真もしくは偽が確定するまで評価を継続する
                                
                                ```ruby
                                1 && 2 && 3 #=> 3
                                1 && nil && 3 #=> nil
                                1 && false && 3 #=> false
                                nil ¦¦ false #=> false
                                false ¦¦ nil #=> nil
                                nil ¦¦ false ¦¦ 2 ¦¦ 3 #=> 2
                                
                                # Alice、Bob、Carolと順に検索し、最初に見つかったユーザ（nilまたはfalse以外の値）を変数に格納する
                                user = find_user('Alice') ¦¦ find_user('Bob') ¦¦ find_user('Carol')
                                # 正常なユーザであればメールを送信する（左辺が偽であればメール送信は実行されない）
                                user.valid? && send_email_to(user)
                                ```
                                
                        - 優先順位
                            - and or not　といった&& || !　に近い演算子
                                - 優先順位が低くなる
                                    - 英語と記号を混ぜて記載すると結果が変わる
                                - and or には優先順位が存在しない
                                    - これも結果が変わる
                            - 優先順位が存在する、しないという不具合がある
                                - and or は条件分岐では使用しないようにする
                            
                            ```ruby
                            優先順位
                            高い !
                            		 &&
                            		 ¦¦
                            		 not
                            低い and or
                            ```
                            
                            - and or は制御フローで使用する
                            
                            ```ruby
                            **andの例**
                            
                            user.valid? && send_mail_to user
                            #=> syntax error, unexpected local variable or method, expecting `do' or '{' or '(' (SyntaxError)
                            # ...ser.valid? && send_mail_to user
                            # ... ^̃̃̃
                            
                            上記のような式はエラーになってしまう
                            ↓
                            評価される式
                            (user.valid? && send_mail_to) user
                            
                            これをandを使うと構文エラーになる事がなくなる
                            user.valid? and send_mail_to user
                            ↓
                            (user.valid?) and (send_mail_to user)
                            
                            ＆＆を使う場合には引数を明示する必要がある
                            user.valid? && send_mail_to(user)
                            ```
                            
                            ```ruby
                            **orの例
                            
                            aが真か？
                            aが偽であれば〇〇を実行する**
                            
                            def greet(country)
                             # countryがnil（またはfalse）ならメッセージを返してメソッドを抜ける
                             country or return 'countryを入力してください'
                             if country == 'japan'
                             'こんにちは'
                             else
                             'Hello'
                             end
                            end
                            greet(nil) #=> "countryを入力してください"
                            greet('japan') #=> "こんにちは"
                            ```          
        - unless
            - 条件式が偽の場合のみ処理を実行する
                - if文と反対の処理
                    - if文で否定的な処理を記載している場合にはunless文に書き換える事が可能になる
            
            ```ruby
            status = 'error'
            if status != 'ok'
             '何か異常があります'
            end
            #=> "何か異常があります"
            
            書き換え
            status = 'error'
            unless status == 'ok'
             '何か異常があります'
            end
            #=> "何か異常があります"
            ```
            
            - elseを使って偽でなかった場合の処理を記載する事もできる
            
            ```ruby
            status = 'ok'
            unless status == 'ok'
             '何か異常があります'
            else
             '正常です'
            end
            #=> "正常です"
            ```
            
            - 新たな条件を加えるelseifのような処理はない
            - 変数への代入、後置ifのような形をとる事もできる
            
            ```ruby
            status = 'error'
            # unlessの結果を変数に代入する
            message =
             unless status == 'ok'
             '何か異常があります'
             else
             '正常です'
             end
            message #=> "何か異常があります"
            # unlessを修飾子として使う
            '何か異常があります' unless status == 'ok'
            #=> "何か異常があります"
            ```
            
            - thenを入れることも可能
            
            ```ruby
            status = 'error'
            unless status == 'ok' then
             '何か異常があります'
            end
            #=> "何か異常があります"
            ```
            
            - if＋否定条件は、unless＋肯定条件に書き直すことができる
                - 必ず書き直さなければいけないわけではない
            - if文のほうが読みやすいと思った場合は、if＋否定条件のままでも大丈夫
        - == trueや== falseといった冗長な記載方法を避ける
            - !対象の変数等?と記載する or unless n.zero?
            - trueそのものか？falseそのものかを判定する時には記載する事もある
                
                ```ruby
                some_value = true
                # 1や'OK'ではなく、trueであるかどうかを判定したい
                if some_value == true
                 'trueそのものです'
                end
                ```             
        - case/when
            - 一つのオブジェクトや式を複数の値と比較する時にシンプルに記載できる
                - 最終的に評価された式を返り値として返す
            
            ```ruby
            case 対象のオブジェクトや式
            when 値1
             # 値1に一致する場合の処理
            when 値2
             # （値1に一致せず）値2に一致する場合の処理
            when 値3
             # （値1にも値2にも一致せず）値3に一致する場合の処理
            else
             # どれにも一致しない場合の処理
            end
            ```
            
            - C言語やJavaScriptの構文に似ているがswith文とは違いbreakというキーワーどが必要ない
            - whenに複数の値を渡して検証する事ができる
                - また、when節の後ろにはthenを使用する事もできる
                    - そのwhenの条件が偽だった場合に真だった場合の処理を一行で記載でき
            
            ```ruby
            # when節に複数の値を指定する
            country = 'アメリカ'
            case country
            when 'japan', '日本'
             'こんにちは'
            when 'us', 'アメリカ'
             'Hello'
            when 'italy', 'イタリア'
             'Ciao'
            else
             '???'
            end
            #=> "Hello"
            ```
        - 条件演算子　＝＞　三項演算子
            - ? や :　を使った三項演算子をする事ができる
                - ´´´Ruby
                n = 11
                if n > 10  
                '10より大きい'
                else
                 '10以下'
                end
                #=> "10より大きい"
                ↓
                三項演算子を使って書き直す

                n = 11
                n > 10 ? '10より大きい' : '10以下'
                #=> "10より大きい"

                変数へ戻り値を代入する事もできる
                ´´´
        - 簡単な条件分岐であればif文やunless文を使うよりも三項演算子を使用すると短く完結にかける
    - メソッド
        - メソッドとは？
            - 処理をまとめるもの
                - 例えば、料金計算システム
                    - 内容は金額の計算の処理
            - メソッド名をつける時には概念を掴んだ名前にする
                - メソッド名を見たら中身の処理内容が一意にわかるように
            - なぜ処理をまとめるのか？
                - メソッドを作ることで処理に名前をつける
                    - 金額の計算 => clucrateAmount(金額の計算)
                        - 金額 => 物の値段 * 税率 => 100 * 1.1
                        - 100 * 1.1 => これ何？
                        - def clucrateAmount 100 * 1.1 => 金額の計算してる
                        - 変更しやすい => 使い回せる　（可読性）
                - 料金計算システムにおいて
                    - 金額の処理は一つだけとは限らない
                        - ex 食事の計算, テイクアウトの計算, ドリンクの計算
                    - 食事の計算
                        - 食事の値段 * 1.1, テイクアウトの値段 * 1.1, ... 無限に増えていく
                    - メソッドがあれば一つで済む
                        - 食事の計算 clucrateAmount()
                        - テイクアウトの計算 clucrateAmount()
                            - 同じ処理を書かなくて済む
                            - 変更箇所が1箇所だけになる
                                - だから、変更に強いコードになる
        - 記述ルール
            - メソッド名　＝＞　小文字スネークケース
            - 変数名　＝＞　小文字スネークケース
        - メソッドを定義する目的（まとめ）
            - 複数の処理をまとめるもの
                - 処理がまとまる事でコードが短くなる事（凝縮性が高くなる）
                - 変更箇所が少なくなる（保守性が高い）
                - シンプルに描ける
                - だれが読んでもわかる（可読性）
        - def メソッド名 (まとめたい処理を記載する) end
            - 引数を受け取るメソッド
                - メソッド名（値）とする
                - メソッドは指定した値を受け取って引数に代入される
        - 引数を受け取るメソッド
            - def メソッド名（引数）end で引数を指定できる
                - 引数を受け取るにはメソッドの呼び出しの際に引数を渡す
                    - メソッド名（引数に渡したい情報）
                - 引数はメソッド内で変数として扱うことができる
                    - def メソッド名（引数） puts "#{引数}” end
                        - 引数を設定したメソッドは引数を指定せずに呼び出すとエラーになるで注意が必要
                - 引数を指定せずに呼び出してもエラーにならない方法
                    - デフォルトの値を設定する方法
                        - ´´´Ruby
                            def メソッド(引数1 = デフォルト値1, 引数2 = デフォルト値2)
                            # 必要な処理 
                            end
                            ´´´
                        - デフォルトの指定があるメソッドと指定がないメソッドを混在させる事も可能
                            - また、動的に値が変わる値を入れたり、メソッドの戻り値を指定する事もできる
                - 複数の引数を受け取る
                    - 引数は複数受け取る事ができる
                        - 括弧の中で引数をコンマで区切ることで複数の引数を指定できる
                            - （引数１、引数２）
                    - 引数を囲んでいる括弧
                        - 省略して記載しなくても動作する
                            - カッコを記載せずにメソッドを呼び出す慣習
                                - 引数が1つもない場合
                                - グローバル関数っぽく使えるメソッドの場合
                                - requireやraiseのような予約語のように見えるメソッドの場合
                    - 複数の引数を渡す際
                        - 定義の時と同じ順番で引数の記載をする必要あり
                - キーワード引数
                    - 複数の値を受け取る際に引数が多くなってしまい区別ができなくなってしまう事があるためキーワードを付けて可読性が高いコードにする
                        - def メソッド名（引数、引数）→（引数:,引数:コロンをつけるようにする
                            - 処理 end メソッド名（キーワード引数:値、キーワード引数:値）
                - 受け取る引数の前にスペースを入れてしまうと構文エラーが起きてしまう。
        - 戻り値のあるメソッド
            - 実際の使用例：
                - メソッドの中でreturnを使うと呼び出し元で値を受け取れるようになる。return 値 と記載するとメソッドが戻り値として返してくれるようになる
                - def discount(price) return price /2 end
                - harf_price = discount(15000)
                - puts “特別価格で＃{harf_price}円です”
            - 処理の流れ
                →メソッドに渡す引き数はメソッドを呼び出す際に一緒に引き数を渡してあげる
                →def メソッド（引き数）として定義する
                →その後、メソッドを呼び出す際に引き数を一緒に渡す
                →メソッド内で処理された戻り値を得る事が出来る
            - 戻り値のあるメソッド（return）
                - メソッド内でreturnを使用する事でその値を戻り値として返す
                    - def add(a,b) return a+b end
                        - 戻り値の出力は一度変数へ代入した後に出力する
                            - if文のような条件式を作ることもできる
                                - メソッド名？条件式とすることで真偽値を返す
                                
                                ```ruby
                                def negative? (number)
                                	return number < 0
                                end
                                
                                puts negativ?(5)
                                ```
                                
                                - returnは処理を終了させる性質を持っていてretrurnのあとに追加で処理を書くことはできない
                    - if文を組み合わせた複数のreturn
                        - 条件分岐を組み合わせて複数のreturnを定義することが可能
                            - def メソッド名（引数）
                            
                            ```ruby
                            if 条件式
                            	return
                            		処理
                            	end
                              return
                            	  処理
                              end
                            puts メソッド名（引数）
                            ```
            - 型
                - Rubyの戻り値に型は記載しない
                    - 最終的に評価されたしきがメソッドの戻り値になる
                - returnの記載は必要ない
        - 真偽値を返すメソッド
            - if文で使用したような条件式をreturnすると条件式の結果として真偽値を返す事ができる
            - 真偽値を返すメソッドは末尾に？をつける習慣がある
        - インスタンスメソッド
            - 単純なメソッドはメソッド名を入力するのみで呼び出す事が出来るがインスタンスメソッドの場合にはインスタンス名.メソッド名とする事で呼び出す事が出来る
                - クラスから使う事ができないため、一度インスタンスを作成してから作る
        - クラスメソッドについて
            - class内でメソッドを定義できる
                - def クラス名.メソッド名 end とする事で定義する事ができる。
            - インスタンスメソッドと違う部分はメソッド名の前にクラス名を書く必要がある
                - classで定義したメソッドはインスランスに対して使用する
                    - インスタンス.メソッド名　とすることで呼び出すことが可能
        - ?で終わるメソッド => 述語メソッド
            - Rubyのメソッドは?や!で終わらせる事ができる
              - ?や！で終わるメソッドは習慣的に真偽値を返すメソッドになっている
                - 例：
                    empty?
                    - JavaにおいてはisEmpty()のようなメソッドになる
                        - ？や！で終わるメソッドは自分で用意する事ができる
                            - その場合には真偽値を返すようにする
        - 破壊的なメソッド
            - ！で終わる述語メソッドは注意する必要がある
                - 例：
                    - Stringクラス
                        - 文字列を大文字にするメソッド
                            - upcaseメソッド
                                - 元の文字列は変えずに文字列を大文字に変更するメソッド
                            - upcase!メソッド
                                - 元の文字列毎大文字に変換するメソッド
                                    - !がつくメソッドは呼び出し元の状態も変更してしまうという点がある
            - まとめ
                - !が付くメソッドは!が付かないメソッドよりも危険
                - 非破壊的メソッドと破壊的メソッドの2種類が存在する場合は後者に!が付く。
                - 破壊的メソッドであっても非破壊的メソッドがない（つまり1種類しかない）場合は!が付かない。
                    - そのため!がついているメソッドが全て破壊的なメソッドであるという事にはならない
                - 破壊的かどうかに関係なく、安全なメソッドと危険なメソッドの2種類が存在する場合にも後者に!が付く。
        - メソッドには!や？をつける事が可能だが変数にはつける事ができない
        - オーバーライド
            - クラスの継承をした親クラスのメソッドを上書きする
                - 子クラスでもん同メソッドで再定義する事で上書きできる
        - 特異メソッド定義式というのもある
        - クラスメソッドについて
            - クラスに属するメソッド＝クラスメソッドはPerson自身に関する情報の変更や参照の役割をもっている。
            - initializeメソッド
        - インスタンスを作成した直後に処理を実行する事ができる。
            - クラス.newでインスタンスを生成した直後に自動で実行される
        - initializeメソッドが実行される処理の流れ
            - クラスの作成（initializeメソッドを定義）
                
                →インスタンス変数の作成
                
                →インスタンスの作成
                
                →initializeメソッドが自動で実施される
                
            - 通常のメソッドと同様に引数と戻り値を設定できる
                
                ```ruby
                show(date) puts "わたし＃（date）" Menu.show(0)
                
                ```
                
            - initializeメソッド内で(self.変数名)として値を代入する
                - self.name= "piza" →メソッド内で変数名を代入してしまうと全てのインスランスでそれが適応されてしまうため各々で変える必要がある。
                    - 引数をinitializeメソッドで定義してインスタンス作成時（クラス.new）に引数を渡す事で個別に分けることができる
                    - 引数を渡す時には『キーワード引数』を使う事で見やすく書く事ができる
        - エンドレスメソッド
            - Ruby3.0以降導入された構文
                - endを省略して記載する事が可能
                    - メソッドが一行で完結する場合に使われる
            - Ruby3.1になってさらに更新された
                - Ruby３.0の場合には()を引数として受け取るメソッドは定義する事ができなかった
                - Ruby3.1になるってからは()として引数を受け取る事も可能になった
            - まだする事ができない機能
                - private def greet = puts 'Hello'
                構文エラーになってしまう
                ↓
                - private def greet = puts('Hello')
                ()をつけて指定するとエラーにならずに実行する事ができる
        - エイリアスメソッド
            - まったく同じ実装で名前だけ異なるメソッドのことをエイリアスメソッドと呼ぶ
                - 例：
                    - size
                    - length
                - チーム開発においては規約で使うメソッドが指定される
                    - エイリアスメソッドは自身で定義する事もできる
        - ターミナル（標準出力）への出力をするメソッド
            - puts
                - 改行を加えて変数、メソッドの内容を表示する
                    - puts自身の戻り値はnilになる
            - print
                - 改行を加えずに出力する
                    - 文字列の出力時にがダブルクオートで囲まれて出力される
            - p
                - pの後に渡されたオブジェクトそのものがメソッドの戻り値になる
            - pp
                - 大きく、複雑な配列、ハッシュ、オブジェクトを整形して出力する
                    - pメソッドで出力した後に見ずらい場合などに使用する
            - 同じような機能がある4つメソッドの使い分け
                - putsメソッド,printメソッド => 一般ユーザ向け
                    - 内部的にto_sメソッドを呼び出している
                - pメソッド,ppメソッド => 開発者向け
                    - inspectメソッドを呼び出す
                        - 内部的にStringクラスのinspectメソッドが呼び出される
        - 文字列に変換するメソッド
            - to_sメソッド
                - ユーザー向けに処理が実行される
            - inspectメソッド
                - 開発者にとって必要な情報を返す
        - グローバル関数のように使う事ができる関数
            - モジュールに組み込まれたメソッド
                - グローバルメソッドのように使う事ができる
    - 引数
        - 引数とは？
            - メソッドに渡す変数のようなもの
                - メソッドに渡す値に型の制限はない
        - メソッドに引数を渡す？
            - メソッドに渡せる変数のようなもの
        - 例えばclucrateAmount(金額)メソッドがある場合
            - 物の値段 * 税率という内容になる
                - 基本、税率は一定である
                - 物の値段は、変わる
                    - この場合、引数に何の値を渡せば良い？
                        - 物の値段を渡す
            - 変わるもの(変数)は、引数で渡す
            - 変わらないもの(計算式など)は、メソッドの中で書く
        - 食事代の計算
            - clucrateAmount(食事代)メソッド
                - 食事代 * 税率
                    - テイクアウト
                        - clucrateAmount(テイクアウト代)メソッド
                            - テイクアウト* 税率
    - 指数表現
        - 浮動小数点を表現する事ができる
            
            ```ruby
            2e-3 #=> 0.002
            ```           
    - 戻り値(返り値)
        - 戻り値とは？
            - メソッドの結果
        - なぜ、メソッドの結果が必要なのか？
            - clucrateAmount(金額)メソッド
                - メソッドを使うには
                    - メソッドを定義する。
                    - 定義したメソッドを呼び出す
                - この場合、メソッドの結果として何が欲しい？
                    - 例えば、食事代, テイクアウト代, おもちゃ代
                        - これが戻り値
                    - 戻り値を返さないメソッド
                        
                        ```ruby
                        def メソッド名
                        	処理内容
                        end
                        ```
                        
                    - 戻り値を返すメソッド
                        
                        ```ruby
                        def メソッド名
                        	return 処理内容
                        end
                        
                        ```
                        
                        - 食事代, テイクアウト代, おもちゃ代
                            - 呼び出し元で適切な戻り値を得る
                                - 食事代が欲しいとき
                                    - eate = clucrateAmount(食事代)メソッド
                                - テイクアウト代
                                    - takeOut = clucrateAmount(テイクアウト代)メソッド
    - クラス関連
        - クラス
            - クラスとは空の設計図のようなもの
                - 例えば、humanクラスのようなもの
                    - 言い換えれば、上位概念である
            - クラスの実態はインスタンスとインスタンス変数である
                - Menuクラス
                    - インスタンス(実態)
                        - スパゲッティ
                        - うどん
                        - ステーキ
                    - インスタスメソッド(実態)
                        - 価格の計算
                        - セールメソッド
                            - 3つ以上買えば、割引になる
            - なぜクラスをつくのか？
                - クラスは変更しやすい
                    - 変更しやすいとは、変更箇所が少ないという事
                - クラスは変更がしやすいもの
                    - 例えば、Menuクラスにインスタンス変数として
                        - 価格とメニュー名とカロリー
                            - インスタンスとして
                                - スパゲッティ
                                - うどん
                                - ステーキ
                                - スパゲッティ
                                    - 価格とメニュー名とカロリー
                                        - うどん
                                    - 価格とメニュー名とカロリー
                                        - ステーキ
                            - Menu classにDrink Menuを追加したい時に
                                - すでにある価格とメニュー名とカロリーを活用して
                                    - インスタンス変数を
                                        - 価格とメニュー名と容量　とできる
                                            - この時の変更箇所は
                                                - カロリー　→　容量　のみになった
            - class クラス名とする事でクラスの定義をする事ができる
                - クラス名は大文字で始める、endを書くという事に注意
            - クラスの中でメソッドをを使う方法
                - クラスに対してメソッドを呼び出す形になる
                    - インスタンス.メソッド名　とする
        - クラスの概念に名前をつける
            - クラスの概念例
                - 人間
                - メニュー
                - 色
                - 会社
                - ゲーム
            - インスタンスは実際の名前
                - 人間クラス→六倉、豊田
                - メニュークラス→ハンバーグ、ステーキ、スパゲッティ
                - 色クラス→黒、白、赤、緑
                - 会社クラス→Sony、DeNA、Nintendo、ASICS
                - ゲームクラス→Switch、PS
                    - etc....
            - インスタンス変数はインスタンスを抽象化した名前
                - インスタンス変数の役割
                    - クラスからインスタンスを作成する際に情報を渡すパラメーター、変数
                        - 人間クラスのインスタンス変数→名前、年齢、性別、宗教
                        - メニュークラスのインスタンス変数→名前、値段、カロリー、提供時間
                        - 色クラスのインスタンス変数→名前
                        - 会社クラスのインスタンス変数→名前、年商、社員数、創業年数、所在地
                        - ゲームクラスのインスタンス変数→名前、値段
        - クラスの継承
            - 親クラスを元に子クラスを作る
            - 継承の対象になるもの
                - インスタンス変数
                インスタンスメソッド
        - インスタンス
            - クラス（設計図）を元に作られたもの
                - human class
                    - 豊田インスタンス
                    - 六倉インスタス
                    - 堤竹インスタス
        - インスタンス変数
            - インスタンスに共通する動作、状態、概念
                - 価格
                - メニュー名
                - カロリー
                    - Menuクラス
                        - スパゲッティインスタンス
                            - 価格, メニュー名, カロリー
                - 体重
                - 身長
                - スピード
                - スタミナ
                    - humanクラス
                        - 豊田インスタンス
                            - 体重70kg 身長180cm スピード 普通 スタミナ 普通
                        - 堤竹インスタンス
                            - 体重60 身長165cm スピード高 スタミナ低
            - 記載方法
                - クラス内でattr_accessor シンボル変数名とする事で変数名の情報を持たせる事ができる
    - 複数の値を管理する方法（配列、ハッシュ）
        - 配列
            - 配列とは？
                - 複数の値をインデックス番号を使って管理するもの
            - 配列名＝[”値を入れる”,”値の間隔は,で区切る”]
                - names = ["mutu", "toyoda", "suzuki"...]
                    - 配列内の要素はインデックス番号が割り振られている
                        - 0,1,2,3
                - 配列の要素を用いる方法
                    - 配列名[インデックス番号]とする事で用いる事ができる
                        - 配列の最初のインデックス番号は[0]になる
                            - names[1]とすると、配列namesの2つ目の要素の値を用いることができる
        - ハッシュ
            - ハッシュとは？
                - 複数の値に対してキーをつけて、キーと1対1の関係性を作って管理する方法
            - names = {キー => 値1, キー => 値2,}
            puts names[キー]
            names[キー] = 値
            - ハッシュの要素を更新する
                - **ハッシュ[キー] = 値とする事で一番最後に更新されたものが適応される**
            - ハッシュに要素を追加する
                - ハッシュ[新しいキー] = 値
            - ハッシュは１つの要素のため変数に代入することができる
                - ["name => kouki"] user =["name => kouki"]  puts user ["name => kouki"]
                    - puts 変数とするとハッシュがかっこを含めてそのまま出力され
            - ハッシュの各要素は対応するキーを使って用いることができる
                - ["name => kouki"] user =["name => kouki"]  puts user["name"] 　出力　kouki
    - 特定の値を取り出したい場合
        - キーで指定する方法やハッシュで指定する方法がある
            - キーの場合
            【キー1　,　キー2　.　キー3　】
            - ハッシュの場合
            ｛key1 =< "キー1" , key2 =< "キー2" ,  key3 =<"キー3"　｝
        
        ```ruby
        exam = {"subject" => "Math", "score" => 80}
        puts exam ["subject"]
        ↓
        Math
        ```      
    - 繰り返し処理
        - eachメソッドを使い繰り返し処理を行う
        
        ```ruby
        **languages = [”japan”,”english”,spanish”]
            
            languages .each do |language|
            
            puts “#{language}を話せます”
            
            end**
        ```
        
        - 上のように配列を作成
            - 配列名 .each do |代入したい変数名| 実行したい処理 endとする事で配列の要素を一つづつ取り出して変数に代入して処理を実行できる
    - シンボル
        - シンボルとは、文字を「"」や「'」で囲む代わりに、先頭に「:」をつけた書き方のこと
        - ハッシュのキーにシンボルを用いると省略した書き方が可能になる
            - 「:key =>」を「key:」のようにできる
        - 基本的には通常通りの使い方が可能になる
        - 要素の前にシンボルをつけてダブルクォーテーションは不要になる
        
        ```ruby
        name ={:name1=>"kouki" }
        puts name 【:name1】
        ↓
        kouki
        
        name ={name1:　"kouki" }
        puts name 【:name1】→要素の取得の場合にはシンボルは変わらずに前でつける
        ↓
        kouki
        ```
    - スコープ
        - メソッドや変数の使える範囲の事をスコープという
            - def #実行したい処理 end の後は使用する事ができない指定した要素がどこの範囲まで影響するか
        - 変数の場合には
            - ローカル変数 or ＠のついている変数なのか？という違い
    - nil
        - 存在しないキーの出力（nil）
            - ハッシュから存在しないキーを出力した際には何もないという意味の「nil」になる
        - 値が存在しない事を示す
        - nilはif文の中で真偽値ではなくtrue or nil(falseとして扱われる)として扱う事ができる
            - if ハッシュ[キー]　処理　else　処理　end
            - キーが存在する場合にはtrueとなり処理が実行される
                - 存在しないキーの場合にはelseの処理が実行される
                    - 配列の要素としてハッシュを入れる事もできる
                        - [　{ キー１：値１、キー２：値２}]
                            - 配列内の要素はインデックス番号が振られているため
                            - 配列［インデックス番号］で対応するハッシュを用いる事ができる
                            - ハッシュの中の値を用いる時には
                                - 変数名　＝　配列［インデックス番号］　でハッシュを変数へ代入して
                                - 変数名［:キー］とする事で用いる事ができる
                                    - もしくわ、配列［インデックス番号］［キー］で一行で特定のキーを用いる事ができる
    - コンソール
        - なぜ入力待機になるのか？
            - getsメソッドで入力待機状態になる
                - 入力待機にするメソッドは他にあるか？
                    - そもそもgetsメソッドを使うと入力する事ができるようになる
                        - chomp
                            - 入力された内容が文字列に変換される
                            - Enterが入力された時に改行が入るのではなく処理が終了になる
                        - to_i
                            - 入力された内容が数値に変換される
        - コンソールへの入力内容はどのように処理されるか？
            - 入力内容
                
                ↓
                
            - 処理が実行される
                
                ↓
                
            - 出力
    - 組み込み型ライブラリ
        - Rubyに用意されているクラスの種類
            - https://docs.ruby-lang.org/ja/latest/library/index.html
                - 組み込み型のライブラリ
    - return
        - Rubyにもreturnというメソッドが存在する
        - 使用する条件：
            - 条件式において処理を途中で離脱したい場合などに使用される
    - ガベージコレクション（GC）
        - garbage collectionというRubyにデフォルトで備わっている機能
            - Rubyは使わなくなったオブジェクトを自動で開放する
                - メモリ管理をしなくても良いためプログラマーに優しい
    - ライブラリ
        - 組み込みライブラリ
            https://docs.ruby-lang.org/ja/latest/library/_builtin.html
            - String
            - Interger
            - Array
            - Hash
        - 標準ライブラリ
            https://docs.ruby-lang.org/ja/latest/library/index.html
            - date
            - fileutils
            - irb
            - bundler
                - gem化された標準ライブラリもある
                    - rubyのインストール時に最新版がアップデートがされる
                        - Rubyの更新を待たずに最新版の取得もする事ができる
        - gem => 外部ライブラリ
            - rails
            - rspec
            - nokogiri
            - sinatra
        - 組み込みライブラリでない標準ライブラリ,gemを利用する場合
            - 明示的にライブラリを読み込む
                - require　ライブラリ名
        - 自分で作成したRubyプログラムを読み込む場合
            - require_relativeを使う
                - 自分のファイルを相対パスで指定する
    - コーディング規約
        - Ruby公式の規約はない
            - 自由な言語だから？
        - ネット上の有志の開発者が作成した規約がある
            - The Ruby Style Guide
                - RuboCopというコード解析ツールで採用されている
    - テスト
        - プログラマの3大美徳
            - 怠惰・短気・傲慢
                - 怠惰
                    - 全体の労力を減らすために手間（つまりプログラムを書いたり、コードを改善したりすること）を惜しまない気質
                - 短気
                    - コンピュータの動作が怠慢なとき（つまりプログラムの品質が悪いとき）に感じる怒り
                - 傲慢
                    - 自分の書いたプログラムは誰に見せても恥ずかしくないと胸を張って言える自尊心
        - 怠惰
            - テストの自動化
                - テスティングフレームワークを作成する事で自動で実行結果をチェックしてくれる
                    - 実行結果に間違えがあれば教えてくれる
- 概念
    - プログラムの本質
        - データと処理（コンピュータへの命令）
            - 処理は川の流れに例えられる
                - 順次進行
                - 分岐
                - 繰り返し
- 学習を進める際のエラーが起きた時の対応
    - 入力したコードに誤りがないか、もう一度見直す。
    - irbで実行している場合は、irbを再起動してもう一度試す。
    - irbではなく、「1.6.2　ファイルに保存したRubyプログラムを実行する」の項で説明したようにサンプルコードを適当なファイルに保存し、rubyコマンドを使って実行してみる注25。
    - 第12章のデバッグ技法を読んで、自分の力で解決を試みる。
    - 使用しているRubyのバージョンが3.0系であることを確認する。バージョンが異なる場合はRuby 3.0に切り替えて実行してみる。
    - 技術評論社の正誤表を開き、内容の訂正が入っていないか確認する。
    - 筆者が開設しているサポートページを開き、Ruby 3.1以降の仕様変更に起因する問題でないか確認する。
- 公式リファレンスの解説
    - https://docs.ruby-lang.org/ja/latest/class/String.html
        
        ↑
        
        公式リファレンスの最新版
        
        latestが最新という意味
        
    - https://docs.ruby-lang.org/ja/2.7.0/class/String.html
        
        ↑
        
        Rubyのバージョン2.7.0のリファレンス
        
        2.7.0のようにバージョンを指定する事も可能
        
    - 最も正確で正しい情報は公式リファレンスにかなうものはない
        - 参照する癖をつけておく

## **プロを目指す人のためのRuby入門**

- 進捗管理
    
    https://gihyo.jp/dp/ebook/2021/978-4-297-12438-0
    
    - 全13章　537P
        - ~~第1章 本書を読み進める前に. 1~19/537~~
        - 第2章 Rubyの基礎を理解する. 21~83/537
        - 第3章 テストを自動化する. 85~98/537
        - 第4章 配列や繰り返し処理を理解する. 101~165/537
        - 第5章 ハッシュやシンボルを理解する. 167~199/537
        - 第6章 正規表現を理解する. 205~230/537
        - 第7章 クラスの作成を理解する. 231~314/537
        - 第8章 モジュールを理解する. 315~364/537
        - 第9章 例外処理を理解する. 365~401/537
        - 第10章 yieldとProcを理解する 403~435/537
        - 第11章 パターンマッチを理解する. 437~477/537
        - 第12章 Rubyのデバッグ技法を身につける. 479~501/537
        - 第13章 Rubyに関するその他のトピック. 503~537/537
- 学習の進め方
    - 第7章「クラスの作成を理解する」から第11章「パターンマッチを理
    解する」までの内容がかなり難しい
        - 途中で諦めるのではなく読書モードに切り替える
            - 最後まで読み切る事でインデックス（索引）を作る
                - 最終的に実務などでこの本を思い出すようにする
- 各章のまとめを要約
    - 第1章 本書を読み進める前に
        - 学習を進めると例題を解く場面が出てくる
            - 例題はまず本を読みながら手を動かす
        - テストコードを記載する
            - テストの自動化がRubyの場合に事前に準備されいるものが多い
                - テストの自動化も一緒にマスターする
        - 例題は複数回解く
            - 1回目：コードを見ながら写経
            - 2回目；自分で考えてコードを記載する
            - 3回目：以前に書いたコードのリファクタリングをする
        - ファイルに保存したRubyコードを実行する
            - ターミナル
                - ruby ファイルパス
                    - ruby sample.rb
                        - と記載する事でファイル内のコードが実行できる
    - 第2章 Rubyの基礎を理解する
        - Rubyの基礎になる知識を学ぶ
    - 第3章 テストを自動化する
        - テストの自動化
            - Minitestの基本
            - FizzBuzzプログラムのテスト自動化
                - 怠惰なプログラマーを目指す
                    - 人間がコードを全てチェックする　＝＞　労働力・疲れる
                    - コンピューター　＝＞　いくらやっても不満ない
                - テスティングフレームワーク
                    - 標準インストール
                        - Minitest
                        - test-unit
                    - Gemでインストールが必要
                        - RSpec
    - 第4章 配列や繰り返し処理を理解する
        - 学ぶ内容
            - 配列
            - ブロック
            - 範囲（Range）
            - さまざまな繰り返し処理
            - 繰り返し処理用の制御構造
        - 配列とブロックに関しては特にRubyを使う上で使う事が多い概念
            - 時々、また読み直すと良い
        - エイリアスメソッドに関して
            - ほかのさまざまな言語の影響を受けているから
            - 直感的に思い浮かんだ名前でメソッドを呼べるようにしたいから
            - あとからもっといい名前が提案されたから
            - 短く書きたいから／英語として自然に書きたいから
    - 第5章 ハッシュやシンボルを理解する
        - ハッシュ
        - シンボル
            - Rubyの中にはハッシュもシンボルもよく出てくる表現になる
                - Rubyを使っていく上で避ける事ができないものなので何回も復習する
        - メソッド定義時の引数の順番
            - 通常の引数（デフォルト値なし）
            - デフォルト値付きの引数
            - 可変長引数
            - キーワード引数
            - **を使った任意のキーワード引数
                
                ↓
                
        - &blockのようなブロックを一緒に受け取るための引数もある
            - 通常の引数
            - デフォルト値付きの引数
            - 可変長引数（1つだけ）
            - 通常の引数
            - キーワード引数
            - **を使った任意のキーワード引数（1つだけ）
            - &を使ったブロックを受け取る引数（1つだけ）
        - Ruby特有のイディオム
            - 経験者のエンジニア程短縮した記載方法を使う傾向がある
                - 短いコードは可読性が高いが経験が少ないエンジニアには理解が難しい
            - Rubyでは変数への代入自体が戻り値を持つ特性を活かした短縮方法
            
            ```jsx
            # 国名に応じて通貨を返す（該当する通貨がなければnil）
            def find_currency(country)
             currencies = { japan: 'yen', us: 'dollar', india: 'rupee' }
             currencies[country]
            end
            # 指定された国の通貨を大文字にして返す
            def show_currency(country)
             currency = find_currency(country)
             # nilでないことをチェック（nilだとupcaseが呼び出せないため）
             if currency
             currency.upcase
             end
            end
            # 通貨が見つかる場合と見つからない場合の結果を確認
            show_currency(:japan) #=> "YEN"
            show_currency(:brazil) #=> nil
            ```
            
            ↓
            
            ```jsx
            def show_currency(country)
             # 条件分岐内で直接変数に代入してしまう（値が取得できれば真、できなければ偽）
             if currency = find_currency(country)
            	 currency.upcase
             end
            end
            ```
            
        - nilかもしれないオブジェクトに対して安全にメソッドを呼び出したい場合
            - &.演算子を使ってメソッドを呼び出す
                - nilの場合にはnilを返す事ができる
                - 値があるある場合には値を返す
                    - &.を使わない場合にはエラーになってしまう
        - ||=を使った自己代入（nilガード）
            - Rubyではlimit ||= 10のようなコードを頻繁に見る
                - 変数limitがnilまたはfalseであれば、10を代入する（それ以外はlimitの値をそのまま使う）という意味
            - ||の式を評価するタイミング
            
            ```jsx
            limit = nil
            limit ||= 10
            limit #=> 10
            ↑
            limit || limit = 10
            実際、評価される式はこうなる
            
            limit = 20
            limit ||= 10
            limit #=> 20
            ```
            
        - !!を使った真偽値の型変換
            
            ```jsx
            def user_exists?
             # データベースなどからユーザを探す（なければnil）
             user = find_user
             if user
             # userが見つかったのでtrue
             true
             else
             # userが見つからないのでfalse
             false
             end
            end
            ```
            
            ↑
            
            架空のコード
            
            ```jsx
            def user_exists?
             !!find_user
            end
            
            !!を使ってtrueまたはfalseを返すメソッドを作る
            
            !で反転させてさらに!で反転させる
            !!true #=> true
            !!1 #=> true
            !!false #=> false
            !!nil #=> false
            ```
            
    - 第6章 正規表現を理解する
        - 正規表現そのものについて
        - Rubyにおける正規表現オブジェクト
            - 正規表現は何も知らない人がみると呪文のように見えてしまう
                - しかし、その意味を理解すると正規表現の力は強い
    - 第7章 クラスの作成を理解する
        - オブジェクト指向プログラミングの基礎知識
        - クラスの定義
        - selfキーワード
        - クラスの継承
        - メソッドの可視性
        - 定数
        - さまざまな種類の変数
        - クラス定義やRubyの言語仕様に関する高度な話題
            - オブジェクト指向プログラミングのRubyにおいてクラスの定義は重要である
                - 独自のクラスを定義する事は多くなる
    - 第8章 モジュールを理解する
        - モジュールの概要
        - モジュールを利用したメソッド定義（includeとextend）
        - モジュールを利用した名前空間の作成
        - 関数や定数を提供するモジュールの作成
        - 状態を保持するモジュールの作成
        - モジュールに関する高度な話題
            - 小規模プログラミングでは使う事が少ない
            - 大規模プログラミングの場合には必須と言っていい程重要な概念
                - 必要になった時には再度読み返す事ができるようにする
    - 第9章 例外処理を理解する
        - 例外の捕捉
        - 意図的に例外を発生させる方法
        - 例外処理のベストプラクティス
            - 例外処理は「ここぞ！」というときにだけ使う機能
                - やみくもにrescueを使ってしまったりすると問題の多いプログラムになってしまうため注意する事が必要
    - 第10章 yieldとProcを理解する
        - ブロックを利用するメソッドの定義とyield
        - Procオブジェクト
            - 処理の一部に対して外部からカスタマイズ可能な振る舞いを組み込む事
                - 処理の塊　＝＞　メソッド
                    - ではないという概念を柔軟に考える
            - 他のプログラミング言語で似ている概念
                - 関数オブジェクト
                - コールバック関数
    - 第11章 パターンマッチを理解する
        - パターンマッチ
            - 基本
            - 利用パターン
            - 応用的な使い方
                - Rubyスクリプト内
                - Railsアプリ内
                    - どこでもパターンマッチを使う事ができる
            - まだ、新しい機能のパターンマッチには今後、新しい機能が実装される
                - 条件分岐だけじゃないパワフルな機能がある
    - 第12章 Rubyのデバッグ技法を身につける
        - エラーへの対応法
            - バックトレース
            - 例外クラスと原因
            - 途中経過の確認方法
            - 汎用的なトラブルシューティング
                - プログラムがエラーなく一発で動く人は少ない
                    - 解決方法やノウハウを少しでも多く知っている事が重要
    - 第13章 Rubyに関するその他のトピック
        - 標準ライブラリ
        - ツールの使い方
            - トピックを広く浅く学んだ
    - 今後の学習について
        - この本を読んだ人には基本的なスキルは身に付いているはず
            - 公式レファレンスなどを今後は読んでコードを読み書きして経験値をあげる事が必要になってくる
        - 「浅い知識」　＝＞　「深い知識」へ徐々に変えていく

classの定義
　　　class クラス名　とすることで定義することができる
　　　　クラス名は大文字で始める事とendが必要なことに注意
　　　classの内容を設定する
　　　　名前
　　　　値段　の２つの情報を持たせる
　　　　　インスタンス変数
　　　　　　attr_accessor :変数名（インスタンス変数）
　　　　　　　一つのクラスにインスタンス変数は何個でも作ることができる
　　　新しいインスタンスの作成
　　　　クラス名.new→新しいインスタンスが作成される
　　　　　変数名＝クラス名.new
　　　　インスタンスの情報追加の方法
　　　　　インスタンスに情報を持たせるためにはクラスで用意したインスタンス変数に値を代入する事が必要
　　　　　　インスタンス.変数名＝値
　　　　　　インスタンス.変数名とする事でインスタンス変数の値を用いることもできる
　　インスタンスメソッド
　　　インスタンスに対してメソッドを呼び出すということは変わらない
　　　引数や戻り値を受け取る事ができる
　　　self.変数名とする事で呼び出したインスタンスメソッドに呼び出した自身のインスタンスが代入される

例題：合計金額を求めるメソッド
　　購入数が３個以上の場合には100円引きになるようにメソッドを作る
　　　そのメニュー（self.price）と個数（count）をかけて合計金額を計算
　　　合計の個数が３個以上の場合には100を引くようにする

インスタンスの作成と同時にインスタンス変数に値を代入する方法がある
　　今まで
　　　クラスの作成→インスタンス変数の作成→インスタンスの作成→変数に対してそれぞれに値を代入
　　

コードの分割
　　コードの量が多くなってくる際にコードをファイルにクラスで区切る事ができる
　　　index.rb(プログラムの実行部分)
　　　menu.rb(メニュークラスのプログラム)
　　requireメソッドを使って分けて保存しているファイルを読み込む事ができる
　　　「index.rb」　require "./menu"　→require ”./クラスやファイル名（パス名）”
　　　元々、Rubyが用意しているclassを読み込むことができる
　　　　require "date" → require "class名"　で読み込む

インスタンスの一覧表示
　　menu1= Menu.new(name:"すし" , price:900)
　　　Menuクラスからnewメソッドを使ってインスタンスを作成しキーワード引数として定義されているname , priceへ値を渡し、menu1へ代入する
　　menu2=Menu.new(name:"piza" , price:500)
　　　Menuクラスからnewメソッドを使ってインスタンスを作成しキーワード引数として定義されているname , priceへ値を渡し、menu2へ代入する
　　一覧表示をしたいため繰り返し処理を実行したいが現状のインスタンスでは繰り返し処理ができないため配列の形にインスタンスをまとめる
　　　配列の作成
　　　　menus=[menu1,menu2 ...] [要素１、要素２、、、、、 ]
　　　menusを用いて.each doメソッドを使って繰り返し処理を実施する
　　　　menus .each do |menu| puts ”出力したい内容” end
　繰り返し処理を実施する際に番号を付けたい
　　繰り返し処理を実施する際に出力内容の手前に番号をつける
　　　each文の（前）外で数字を指定する　例：index = 0
　　繰り返し処理を実行する度に数字を増やすor減らすなどの処理を実行する
　　　配列名 .each do |変数名|　puts などの処理 index += 1(処理を実行した後にindexに対して1を足し算する) end

入力内容を受け取る
　　gets.chompメソッドを実行するとコンソールが入力待機状態になり入力された内容を文字列として受け取る
　　　変数に入力内容を代入することで名前入力システムなどが作成できる
　　gets.chomp.to_iメソッドを実行するとコンソールが入力待機状態になり入力された内容を数値に変換して受け取る
　　　変数に入力内容を代入する事で注文システムの個数指示などができる

インスタンスのクラスに合わせて表示内容を変更する方法
　　今までMenuはMenu classとして扱ってきたがFood classとDrink classに分けてプログラムする事で classに応じて表示内容を変更する
　　　クラスの継承を活用しMenu classですでに書いたものを活用する
classの継承
　classを継承する理由
　　コードを共通化できる
　 人間クラス　
　 　男性クラス
　 　女性クラス
　 　　食べる、寝る
　 　　　親クラスがあればクラス毎にコードを開く必要がなく、継承する事で使える

　 スポーツクラス
　 　健常者スポールクラス
　 　パラスポーツクラス
　 　球技クラス
　 　陸上クラス
　class 新しいクラス＜元となるクラス　（子クラス＜親クラス）
　　継承されるもの
　　　インスタンス変数
　　　インスタンスメソッド
クラスの継承をした後もインスタンス変数を作る場合にはattr_accessorメソッドを使う
　class Food＞Menu 　attr_accessor :calorie end
クラスの継承をした後もインスタンスメソッドを作る際にはdefメソッドを使う
　class Food＞Menu 　def calorie_info end   end
オーバーライド
　親クラスと同名のメソッドを子クラスで使用すると親クラスで定義されているものが呼び出されるが子クラス内でメソッドを再定義すると子クラスで再定義されたものが呼び出されるようになる
　　上書きされる印象だが実際には子クラスのインスタンスでは子クラスのメソッドが優先的に呼び出される仕様になっているため上書きされたような感覚になる
　　 Super
　　  オーバーライドしたメソッド内で親クラスで使っていたメソッドを用いる事ができる
　　   initializeメソッドなどにおいて
　　  　 class Food > Menu def initialize (name: , price:, calorie:) Super (name: name , price: price) self.calorie = calorie end  end　とするとすると
　　  　  Menu classをFood class に継承する　initializeメソッドの再定義を行いname price に加えてcalorieを付け加える、インスタンス作成時にインスタンス自身の引数を name price calorie に代入して欲しいためself.を活用する。Menu classですでにname price のメソッド内容は作成済みのためSuper メソッドを活用してMenu classのメソッドを呼び出す。メソッドを呼び出した際にキーワード引数に対応した引数を渡す必要があるため（name: name←Menu class でself.nameと定義している , price: price Menu class でself.price と定義している）→Food classのキーワード引数:Menu classの引数の形で引数を渡しインスタンス作成時にインスタンス自身から値が代入されるようにする

曜日に応じて値引きをする方法
　　date class の使い方
　　　他のclassと同じように.newメソッドを使いインスタンスを作成する。作成する際に（年,月,日）となるように引数を渡す
　　　　require "date" date1=Date.new(2025,1,4) puts date1
　　　Date class には多くのインスタンスメソッドが用意されている
　　　　.sunday?メソッド　（インスタンスメソッド）
　　　　　日曜日かどうか？を真偽値で返すメソッド
　　　　　　puts date1.sunday?→date1というインスタンスに対して.sunday?というインスタンスメソッドを呼び出した
　　　　.todayメソッド　（クラスメソッド）
　　　　　今日の日付を作る事ができるクラスメソッド
　　　　　 インスタンスに対するメソッドではなくクラス全体で使えるメソッド
　　　　　 　インスタンスではないためクラスをメソッド内で活用する事ができる
　　　　　呼び出す方法は定義時と同じようにクラス.メソッド名で呼び出す
[https://scrapbox.io/files/67793799b3fb73e91c91ae80.png]
↑
Menu .is _discount _day?→クラスメソッド（クラス全体で使用できるもの）
Date .today→クラスメソッド（クラス全体で使用できるもの）
today.sunday?→Date class内にあるメソッド
get_total_price→インスタンスメソッド（インスタンスに対して使用でき全体には影響しない）

ーーーーーーーーーーーーーーーーーーーーーーーーーーーー
⚫️概念整理
classの実態
classとは
　プログラムの実態はデータと処理である
　　Rubyにおけるデータと処理
　　　データ
　　　　　　変数
　　　　　　クラス
　　　　　　インスタンス
　　　　　　文字列
　　　　　　数値
　　　　　処理
　　　　　　メソッド
　　　　classの継承で子クラスに継承されるものは何か？
　　　　　　クラスの実体はインスタンス変数とインスタンスメソッドである
　　　　　　　インスタンスはクラスの実態ではなくクラスを元に生成されたものの実体

インスタンスメソッドとは
　　インスタンスに対して使用する事ができるメソッド
　　　def メソッド名 end
　　　　インスタンス（六倉、豊田、堤竹）に対するメソッド
　クラスメソッドとは
　　クラス内で使用する事ができるメソッド
　　　def クラス名.メソッド名 end
　　　 クラス（人間クラス、Drinkクラス、Foodクラス）に対するメソッド
　　　  インスタンス１つ１つには関係なく、クラス全体に対するメソッド

Ruby
　プログラミング言語　
　　動的なプログラミング言語
　　　データ　＝　状態
　　　　数値
　　　　文字列
　　　　変数
　　　　引数
　　　処理　＝　システムにおける振る舞い
　　　　計算式
　　　　条件分岐
　　　　メソッド
　　　データと処理　　中間　
　　　　インスタンス
　　　　　インスタンス変数　データ
　　　　　インスタンスメソッド　処理
　　　　クラス

https://qiita.com/Hashimoto-Noriaki/items/441003dd2ec358a331b5

##