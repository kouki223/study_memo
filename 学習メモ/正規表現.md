- 正規表現について
    - 学習ソース
        - [正規表現について][1]
        - [微妙な違いを許容しつつ置換しよう][2]
        - [空白文字を自由自在に操ろう][3]
    - 正規表現を説明するとしたら
        - パターンを指定して、文字列を効率よく検索・置換するためのミニ言語
    - 電話番号を探す
        - \バックスラッシュはcommand+|
    - 正規表現において特別な意味を持つ文字　＝＞　メタ文字
        - \dは正規表現で1個の半角数字という意味を持つ
            - 特に文字クラスと呼ばれる
                - //の中に囲まれた表現が正規表現になる
                ```ruby
                text = <<-TEXT
                名前：伊藤淳一
                電話：03-1234-5678
                住所：兵庫県西脇市板波町1-2-3
                TEXT
                text.scan /\d\d-\d\d\d\d-\d\d\d\d/
                # => ["03-1234-5678"]
                ```
            - RubyやJSなどモダンな言語では正規表現はほとんどの言語で使う事ができる
                - JSの場合
                ```JavaScript
                var text = "名前：伊藤淳一\n電話：03-1234-5678\n住所：兵庫県西脇市板波町1-2-3";
                text.match(/\d\d-\d\d\d\d-\d\d\d\d/g);
                // => ["03-1234-5678"]
                ```
                - 最後の g はグローバルオプション
                    - g なし => 最初の1件が見つかったら検索終了
                    - g あり => 一致する文字列をすべて抽出
        - \d\d-\d\d\d\d-\d\d\d\d
            - \d\d => 2個の半角数字という意味
            - -はメタ文字ではないのでそのまま
                - この正規表現が示すのは
            - 半角数字2個、ハイフン、半角数字4個、ハイフン、半角数字4個になる
    - 様々な市外局番に対応する
        - 正規表現を使う時にはパターンを見つけ出す事が必要になってくる
            - 次のような法則
                - 半角数字が2個～5個、ハイフン、半角数字が1個～4個、ハイフン、半角数字が4個
                    - 文字数の個数を指定する時に{n}や{n,m}というメタ文字を使う
                        - {n,m}  => 直前の文字が n 個以上、m 個以下
                        - {n} => ちょうど n 文字
        - 対応した正規表現
            - \d{2,5}-\d{1,4}-\d{4}
    - ハイフンではなくカッコを使うケース
        - パターンを見つける
            - ハイフンまたはカッコ（開き）
            - ハイフンまたはカッコ（閉じ）
                - AまたはBのパターン
                    - これを示す時には[AB]とかく
                        - 文字クラスの一種
                            - [-(]、[-)]と表現する
        - 対応した正規表現
            - \d{2,5}[-(]\d{1,4}[-)]\d{4}
    - []の中のハイフンは注意が必要
        - [a-z] => 「aまたはbまたはcまたは・・・yまたはz」
        - [a-zA-Z0-9] => 「aまたはbまたは・・・z、AまたはBまたは・・・Z、0または1または・・・9」
        - [-az],[az-] => 「ハイフン1文字」 => [-az] や [az-] は「aまたはzまたはハイフンのいずれか1文字」
    - 検索の精度と複雑さ
        - 正規表現を定義すると想定していない検索結果が得られる可能性がある
            - メールアドレスの正確な正規表現
                - (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
                - 毎回このような表現を考える事は難しいためそこそこ正しい正規表現を目指す
                    - 要はトレードオフの関係になる
    - 正規表現を使う
        - 目視で探していた文字列を検索する事ができる
        - 文字列処理において複雑な処理をせずに1発で処理できる
        - 正規表現にも意味がある
    - 絶妙な違いを許容する
        - クープバゲットのパンは美味しかった。
            今日はクープ バゲットさんに行きました。
            クープ　バゲットのパンは最高。
            ジャムおじさんのパン、ジャムが入ってた。
            また行きたいです。クープ・バゲット。
            クープ・バケットのパン、売り切れだった（><）
        - クープバゲットやクープ・バケットなどという表現の揺れを許容しつつ抜き出す
            - クープ バゲット （半角スペース区切り）
                - 1つヒット
            - [AB] => AまたはBのいずれか1文字
                - クープ[ 　・]バゲット
                    - 半角スペースと全角スペースと中黒
                        - 3つマッチ
            - 濁点の有無を許容する
                - クープ[ 　・]バ[ゲケ]ット
                    - 4つヒット
            - 区切り文字の有無を許容する
                - 新しいパターン
                    - 区切り文字が1文字、 もしくは区切り無し
                        - ?というメタ文字を使う => ～が1文字、または無し 量指定子
                            - クープ[ 　・]?バ[ゲケ]ット
            - [ 　・]の表現、現実的には任意の1文字で良い
                - . というメタ文字
                    - クープ.?バ[ゲケ]ット
            ```Ruby
            text = <<-TEXT
            クープバゲットのパンは美味しかった。
            今日はクープ バゲットさんに行きました。
            クープ　バゲットのパンは最高。
            ジャムおじさんのパン、ジャムが入ってた。
            また行きたいです。クープ・バゲット。
            クープ・バケットのパン、売り切れだった（><）
            TEXT

            text.split(/\n/).grep(/クープ.?バ[ゲケ]ット/)
            # => ["クープバゲットのパンは美味しかった。", "今日はクープ バゲットさんに行きました
            ```
            ```JavaScript
            var text = "クープバゲットのパンは美味しかった。\n今日はクープ バゲットさんに行きました。\nクープ　バゲットのパンは最高。\nジャムおじさんのパン、ジャムが入ってた。\nまた行きたいです。クープ・バゲット。\nクープ・バケットのパン、売り切れだった（><）";

            var lines = text.split(/\n/);

            var targets = [];
            for (var i = 0; i < lines.length; i++) {
            if (lines[i].match(/クープ.?バ[ゲケ]ット/)) {
                targets.push(lines[i]);
            }
            }
            targets;
            // => ["クープバゲットのパンは美味しかった。", "今日はクープ バゲットさんに行きました。", "クープ　バゲットのパンは最高。", "また行きたいです。クープ・バゲット。", "クープ・バケットのパン、売り切れだった（><）"]
            ```
    - 置換処理に正規表現を使う
        - 検索、抜き出すどちらにせよパターンを見つける
            - value => ダブルクオート、英数字またはアンダースコアが1文字以上、ダブルクオート
                - 直前の文字が 1文字以上 => +
                - 英数字またはアンダースコア => [a-z0-9_]
                    - value="[a-z0-9_]+"
            - 表示テキスト部分 => > で始まり、何かしらの文字が続き、< で終わる
                - 何かしらの文字列が続く => . と +　で表示できる
            - >.+<
                - 検索方法は上記のようにパターンを見つける事である
        - HTMLからCSVの形に変換する
            - 行全体にマッチする正規表現を作る
                - <option value="[a-z0-9_]+">.+<\/option>
                    - メタ文字　＝＞　[a-z0-9_]+ , .+
                - <\/option>
                    - \⇦このスラッシュは/をエスケープするためのエスケープ文字
                        - Ruby,JavaScriptにおいては/abc/のような正規オブジェクトが出現するのでスラッシュはエスケープする必要がある
            - valueと表示テキストの部分をそれぞれ ( ) で囲んでキャプチャする
                - <option value="([a-z0-9_]+)">(.+)<\/option>
                    - Match groupsという欄が出現する
                        - Match 1
                            1.	wii_u
                            2.	Wii U
                        - Match 2
                            1.	ps4
                            2.	プレステ4
                        - Match 3
                            1.	gb
                            2.	ゲームボーイ
                        - 1 => value 2 => 表示テキスト
                    - ()を使うと()の部分がキャプチャされて連番がつけられる
            - キャプチャを利用して新しい文字列を組み立てる
                - Atomを使って文字列の置換を行う
                    - Replace in current buffer
                        - $1,$2 => キャプチャされた文字列
                            - replace
            - 表示テキストがないoptionも置換できるようにする
                - <option value="([a-z0-9_]+)">(.+)<\/option>
                    - このまま<option value="none"></option>のような表示テキストがないoptionはマッチしない
                - .+ => 任意の文字列が1文字以上 => これを任意の文字が0文字以上に変える
                    - 任意の文字が0文字以上 => .*
                        - <option value="([a-z0-9_]+)">(.*)<\/option>
            - selected状態になっているmultipartも置換できるようにする
                - <option value="wii_u" selected>Wii U</option>
                    - 上のような正規表現だとマッチしない
                - パターンを見つける
                    - "selected"があり、または無し
                        - or条件を追加する
                            - A?のような条件には2文字以上の文字列に対しても使う事ができる
                                - 2文字以上の場合には()で囲んでグループ化した上で?と書く
                                    - (ABC)?
                            - <option value="([a-z0-9_]+)"( selected)?>(.*)<\/option>
                - キャプチャ対象を把握する
                    - ()でグループ化する目的で使った()でも操作しないとキャプチャ対象として扱われてしまう
                        - そこで、(?: )のように？：をつけるようにする
            - 便利なTips
                - [0-9] を \d に置き換える
                    - \d => 半角数字を表すメタ文字（文字クラス）
                        - \d => [0-9]
                - [a-z\d_]+ を \w に置き換える  
                    - \w
                        - 英単語を構成する文字
                            - Ruby,JavaScriptにおいて\w = [a-zA-Z0-9_]となる
                                - [a-z\d_]+と\w+は大文字も含まれてしまう点以外においては同一の操作を行う
                - キャプチャ数の指定
                    - Atom,JavaSript
                        - $1
                    - Ruby
                        - \1
            - **重要**
                - * と + は「貪欲」であることに注意！
                    - *と+は扱い方を間違えるとドツボにハマる
                        - 改行された先ほどのようなコードに対しての操作
                        - 改行されていない１行のコード
                            - プレステ4</option><option value="gb">ゲームボーイ
                                - 結果としてこのように帰ってきてしまう
                                    -  貪欲なマッチ を試みる量指定子と呼ばれる
                - 解決策を考える
                    - 任意の1文字という条件を厳しくする
                        - < 以外の 任意の文字に変える
                            - A以外の 任意の文字を示す　＝＞　[^<]
                                - []の最初に^が入ると否定の意味になる
                                    - <option value="(\w+)"(?: selected)?>([^<]*)<\/option>
                                        - パターンの定義を
                                            - < 以外の任意の文字が0文字以上
                    - 最短のマッチを返すように指定する
                        - > で始まり、任意の文字が0個以上連続し（.*）、 最後に見つかった < で終わる ではなく
                        - > で始まり、任意の文字が0個以上連続し（.*）、 最初に見つかった < で終わる
                            - >(.*?)<のように?をつける事で最短のマッチを返すようになる
                                - **最小量指定子**と呼ぶ
                                    - <option value="(\w+)"(?: selected)?>(.*?)<\/option>
                - ミスが許されない置換は1個ずつ確認しながら実行しましょう
                    - 想定していない文字列に遭遇する事や、意図しない変換などがあり得るのが正規表現による検索や置換になる
                        - ソースコードを変換するなどの行為においては記載してから全て置換としてしまうと危険になってしまう
                            - 置換して次、置換して次と繰り返す事がおすすめ
    - ***正規表現2まとめ***
        - ? は「直前の文字が1個、または無し」を表す
        - . は「任意の1文字」を表す
        - + は「直前の文字が1個以上」を表す
        - * は「直前の文字が0個以上」を表す
        - ( ) はマッチする部分をキャプチャ（捕捉）する
        - キャプチャした部分は置換するときに $1 や \1 で参照できる
        - \w は「英単語を構成する文字（半角英数字とアンダースコア）」を表す
        - [^AB] は「AでもなくBでもない任意の1文字」を表す
        - 正規表現中の特別な文字は \ でエスケープする
        - ( ) はキャプチャだけでなく、グループ化にも使われる
        - (ABC)? は「文字列 ABC があり、または無し」を表す
        - (?: ) はキャプチャ無しでグループ化する場合に使う
        - * と + は「貪欲」で最長マッチを返すため、使い方を誤ると思いがけない結果が返る
        - *? や +? にすると、最短マッチを返す
        - テキストエディタで重要なテキストを置換する際は、ひとつずつ確認しながら置換する
    - ***正規表現3まとめ***
        - ^ は行頭を表す
        - $ は行末を表す
        - \t はタブ文字を表す
        - \n は改行文字を表す
        - \s は空白文字（スペース、タブ文字、改行文字等）を表す
        - ABC|DEF は「文字列ABCまたは文字列DEF」のOR条件を表す
        - 改行コードは環境によって異なる場合がある
        - ^ は行頭の意味になったり、[^ ] で否定の文字クラスの意味になったりする

    [1]:[https://qiita.com/jnchito/items/893c887fbf19e17d3ff9]
    [2]:[https://qiita.com/jnchito/items/64c3fdc53766ac6f2008]
    [3]:[https://qiita.com/jnchito/items/6f0c885c1c4929092578]