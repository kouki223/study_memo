- コードリーディングの方法（流れ）
    - コードリーディングのやり方（流れ）
        - システムの把握
            - どのような課題解決するのか
                - どのような機能で解決するのか
            - 環境構築もしておく
        - 技術の構成　＝　ルートファイルをつくるとか
            - FE
            - BE
            - インフラ
            - ライブラリ
        - ディレクトリレベルでシステムを見る
        - 機能毎にライブラリを見る
            - 機能
                - フロント
                    
                ↓
                    
                - バックエンド
        - ファイルレベルで見ていく

- コードリーディングについて整理する
    - https://qiita.com/zizynonno/items/3a14fe6cbf52451a366c

- 0 前章
    - 0.1 概要
        - エンジニアの仕事の８割以上の時間がソースコードを読む時間になっている
            - ソースコードの読み方について議論するべき
                - デバッガーを使った読み方
                - リーダブルコードの内容
                - Web記事を参照にしてソースコードを読む
                    - 様々な知識が散在している状態になってしまった
        - ソースコードを読む方法を
            - Youtube
            - 記事
                - など、様々な場所から集めてきたチートシートを作成する
    - 0.2 コードリーディングにおける階層
    ![alt text](/Public/コードリーディング.png)
    - コードリーディングという行為の通し番号　＝＞　1~7(全体から詳細へ)　7~1(詳細から全体へ)
        - 業務知識・業務要件・非機能要件(実現したいこと)
        - チームルール
        - IDE(開発ツール)、デバッガ(デバッグツール)、実行環境
        - 設計パターン、データ構造・アルゴリズム、パラダイム・原理原則
        - ライブラリ・フレームワーク
        - 基本文法
        - ソースコードとして書かれている各行
        
    ***最初から詳細を把握する事は難しい***
    - 全体から詳細
        - 「プロジェクト参画1日目」「今まで触れてこなかったサービスの概要を知る時」「issueを解決し始める時」に読む流れ
    - 詳細から全体
        - 「ある程度プログラムを把握し終えた時」「エラーが発生し、原因のコードを把握する時」「実装中に実装目的を振り返りたい時」「既存の関数があるか探したい時」に読む流れ
        
        ↑
      
      **この考えの元、どちらも行き来する事が重要な事**

***1 業務知識・業務要件・非機能要件(実現したいこと)***
- 新しくソースコードを読み進める場合に大事な事
    - 自社のサービスに関して知る事
        - ビジネスサイド
        - エンジニアサイド
            - どちらに関わらず
- 業務知識
    - ビジネスサイドの目的把握
        - 今まで触れてこなかったサービスの概要を知る
            - そのシステムがなぜ作られたか。目的。経緯の把握。(Why)
            - どんな価値をユーザーに提供しているのかの把握。(How)
            - システム上で具体的にどんな業務フロー・顧客の流れかを把握。(What)
        - ビジネスサイドを知る事で協業、ディスカッションが豊かになる
            - 業務知識に関してはドキュメントが存在するはず
                - 無い場合には聞く
    - エンジニアサイドの目的はあく
        - ビジネスサイドから投げられた問題(issue)をどのように処理するのか？
            - メモ
            - コメント欄
            - ソースコードに日本語で記載していく
    - 筆者の知識管理方法
        - 機能要件
        - 非機能要件
            - 2つに分ける
    - **備考：ドキュメントがない、ソースコードにコメントがない時に実装者の意図を把握したい場合**
        - ①git blame ファイル名
            - git blame ファイル名で「最終コミットのハッシュ値」「コミットした人」「コミット日時」「行番号」「行の内容」が取得できる。
                - 「最終コミットのハッシュ値」をGitHubの検索欄に入れて検索かけると、issueが出現する。
                    - issueの内容やコメントなどから前任者の実装の意図を把握する。
        - ②GitHubのHistory欄を使う
            - GitHubのプロジェクト内のファイルページの右上にあるHistoryを押下する。
                - そのファイルの過去のコミットが見える。これによって、issueの内容やコメントなどから前任者の実装の意図を把握する。

***2 チームルールや組織文化***
- コーディング規約やコミットの粒度、コメントやプルリク作成の際のルールなどを把握する。
    - コーディング規約  
        - なんでこんな書き方してるのか？がわかるようになる
    - プルリク作成
        - 開発の背景にある意図を汲み取る事ができる
            - コメントやドキュメントを残す事で前任者の意図を汲み取る事ができる

***3 IDE(開発ツール)、デバッガ(デバッグツール)、実行環境***
- エディタの設定を変える事や、デバッガーを使ってソースコードを読む、Dockerなどの仮想化技術を使って開発者の環境を揃えるなど環境要因によるエラーの可能性を考えなくする

***3.1 IDE(開発ツール)***
- 大雑把に言って解析手法は静的な手法と動的な手法に分類できる。
    - 静的な手法とは、ソースコードそれ自体を読むこと。
    - 動的な手法とは、デバッガなどを使って実行時の動きを追うことだ。
        - 基本的に解析は動的解析から始めるのがよい。
             - 静的解析とは、多かれ少なかれ、プログラムの動作を予想することである。
                - 対して動的解析で見るのは事実である。
                    - まず事実を見ておいたほうが方向付けがしやすいし、間違いも減る。最適化する前にプロファイルを取れ、というのと似ているだろうか。 
                        - 解決はまず現場から、というのでもよい。
**3.2 デバッガ(デバッグツール)**
- 3.2.1 動的解析
    - 使用目的
        - エラーを解決すること
        - プロジェクトの理解が目的
            - プロジェクトで気になるソースコードが見つかったらと適時変換する
- 3.2.1.1 デバッガーを使う
    - Webプログラミング
        - クライアントからのパラメーターを受け取ってサーバーサイドへ送り加工する
        - 時にはパラメーターの値を参照にデータベースから値を持ってくる事もある
            - Webプログラミングというものはバケツリレー大会、駅伝大会なのである
                - エラーは変数の値が予想と違う、大会のルールがロジカルではないなどの理由で起きる
        - どの地点でエラーが発生したのかを解析するのがデバッガーである
            - 目的地を決めた後
                - ブラウザ・URL・バックトレースから判断する
                    - プロジェクトファイルを類推、検索する
                        - それっぽい場所にデバッガーを差し込んで変数の流れを把握する
                - 静的な情報として扱っていたプログラムにデバッガーが動的に情報を作る
                    - 動的な風景になる事で余った脳の部分を静的な解析に使う事ができる
- 3.2.1.2 ソースコードの処理の流れを日本語や図でメモに記載する
    - 日本語に置き換える理由
        - ソースコードは抽象的だから
            - ソースコードの解析というのは抽象概念を具象概念に落とし込む作業と考え
                - 落とし込んだ上で日本語で脳にメモリする事は重要な事になる
    - 我々は日本人である
        - プログラムは英語である
            - 日本語でキリン　英語でGiraffeと言われてもわからない
                - 日本語であればすぐに理解する事ができる
    - 英語の学習をする事も良い
        - その反面、英語ばかりに時間をかける事は難しい部分、
- 3.2.2 静的解析
    - 3.2.2.1 ドキュメントを読む
        - そもそもソースコードを読まない
            - ソースコード読んだら負けかなと思っています。
                - リファレンスマニュアル、ドキュメント
                - 設計関連の文書・資料
                - 自然言語で書かれた素晴らしいものがたくさんあるはず
                    - まずはそっちを読む。
            - ドキュメント等あまり頼れないとき
                - そういったもので解決しないときは、しょうがないのでコードを読む
                    - それでもコメントや識別子の命名を重視して、まずはできるだけ意味的に解釈してみます。
                        - コメント皆無、変数名適当……というケースでは、仕方がない
                            - 他にどうしようもないので、コードロジックを見ていきましょう。
                                - 読むのは面倒くさいので、できればやりたくないことの筆頭
                                    - できるだけやらないで済ませる方法を考える
                                        - 初心者だと読解力不足で捗らないということも多々ある
                                            - よほどの必要性に迫られていなければ「コード読むのは、もう少し上達してからでいいよ」なのではと考える
        - 前任者がドキュメントを残しているはずなので、それを読む。
        https://teratail.com/questions/147782
        - これも前項と似ていて、まず仕様を知っておこうということ。 また内部構造を解説したドキュメントが付いていたらそれもぜひ見ておきたい。
            - 「HACKING」「TOUR」などという名前のファイルがあったら要チェック。
                - 4 設計パターン、データ構造・アルゴリズム、パラダイム・原理原則
                    - 4.1 ディレクトリ構造を読む
                        - ディレクトリ分割の構造を見る
                            - プログラムの作り、パート、概要を見る
                    - 4.2 ファイル構成を読む
                        - ファイルの中に入っている関数、関数名も合わせて一緒に見る
                            - ファイル名も見ておく
                                - ファイル名は衰えないコメントのようなもの
                        - ここで関数の命名規則にもあたりをつけておく
                            - C のプログラムなら extern 関数にはたいていプリフィクスを使っているなど
                    - 4.3 関数同士の呼び出し関係を把握する
                        - 関数名の次に重要な情報
                            - 関数の数が多い場合にはこれが重要になる
                                - ツールを活用する
                                - 自分で図に記載する
                        - 関数同士の呼び出しを図にしたものをコールグラフと呼ぶ
                            - 静的なコールグラフ
                                - プログラムが動作していない環境での関数同士の関係
                            - 動的なコールグラフ
                                - 実際に動作させた時の関係
                    - 4.4 デザインパターン
                    - 4.5 アルゴリズムとデータ構造
5 ライブラリ・フレームワーク
① ファイル
② 関数(メソッド)の種類
③ 型の種類
④変数(インスタンス)
⑤名前空間を用いたクラスの差別化
⑥予約語や識別子
⑦略語の調査
6 基本文法
7 ソースコードとして書かれている各行
7.1 どのような目的で設計されたコードなのかを考える。
①Reliability（信頼性）
②Availability（可用性）
③Serviceability（保守性）(拡張性)
④Integrity（保全性）
⑤Security（機密性）(安全性)
7.2 歴史を読む
①git blame ファイル名
②GitHubのHistory欄を使う
7.3 ちょっと変更して動作させてみる
7.4 irbなどのインタラクティブな機能で試す
7.5 ソースコードを楽しく読みたい(ゲーム感覚で取り組みたい)
8 エラー原因追及の際に切り分ける領域
サービスが止まってる
通信の問題
環境の問題
権限の問題
場所の問題
ロジックの問題
データの問題
リクエスト問題
見え方の問題
9 終わりに


