3月30日
- FE
    - ボタンなどを表示する事ができるライブラリ
        - 一般的にアイコンフォントと呼ばれる
            - headタグ内にライブラリを読み込む事で配下のView内で使う事ができる
                - CDN型
                    - CDNサーバー上にあるファイルを読み込む事で使用できる流れになる
                - ダウンロード型
                    - 一度、サーバーにダウンロードしてから使う方法            
            **CDN型**
            1. Font Awesome
            2. Line Awesome
            3. Google Material Icons
            4. Phosphor Icons
            5. Remix icon
            6. Ionicons
            **ダウンロード型**
            1. IcoMoon
            2. Foundation Icon Fonts 3
            3. Ligature Symbols
            4. Genericons Neue
- BE
    - Ruby
        - Rubyの代表的なライブラリ
            - ライブラリの種類
                - 組み込みライブラリ
                    - 標準的に使う事ができるライブラリ
                        - Integer
                            - 整数
                        - String
                            - 文字列
                        - Array
                            - 配列
                        - Hash
                            - ハッシュ
                - 標準添付ライブラリ
                    - requireメソッドを使って呼ぶ必要がある
                        - JSON
                        - CSV
                - Gem
                    - Gem installする事で使用できる
                        - *RubyGems.orgにGemとしておいてあるもの*
                            - Devise
                                - メールアドレスでの登録
                                    - 他のサービスの利用
                                        - Facebook
                                        - Twitter
                                        - LINE
        - メソッドの例外的な記載方法
            - link_to
                - link_toメソッドにおいてはHTMLのアイコンを表示したい場合などに例外的な記載方法が存在する
                    - そのほかは、基本構文に沿って記載するのがルールになる
        - パスワード管理方法
            - Gemを使ってハッシュで保存する方法
                - Rails８.0以降はRailsにデフォルトでaouthenticationの機能が備わっている
                    - コマンドでrails generate authenticationを実行する事で必要なファイルやGemにインストールがされる
                        - bcrypt
- インターネットセキュリティ関連
    - 考えられる攻撃例
        - BE
            - セッションハイジャック
                - cookie内のsessionIDによって識別している
                    - セキュリティが担保されていないネットワークではsessionIDが傍受される
                        - SSL通信において機密性が担保されていない
                            - ログイン・ログアウトの機能が重要
                                - 目立つボタンにして表示する必要がある
            - セッション固定
                - セッションIDを傍受する方法ではなく
                    - ユーザー側のセッションIDを固定するという方法をとる
                        - クロスサイトスクリプティング（XSS）
                            - JavaScriptコードの注入（インジェクション）
                                - 例：<script>document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9";</script>
        - FE
            - クロスサイトリクエストフォージェリ（CSRF）
                - ログインが失効してしまったと思っているユーザーに違法なリンクを踏ませて認証情報を盗みとる方法
                    - 眠れる巨人
    - 過去のパスワード漏出例
        - パスワード本体に対する対策は施されている
            - ハッシュ化など
        - そもそもの認証情報をハッキングするという攻撃が多い
    - 対策方法を深掘りする
        - Rails
            - authenticateメソッドの処理内容
                - 認証の流れ
                    - 認証ストラテジーの取得
                    - authenticate!
                    - ユーザーをsessionへ格納
                    - ストラテジーの認証が成功しない場合にはsessionへの格納が行われない
        - ハッシュ化
            - ハッシュ化の原理について
                - ハッシュ関数を使って不規則な文字列へ変換する事
                    - 不可逆的な変換
            - 混同されやすい概念として暗号化がある
                - 暗号鍵を使って元データを復元する事ができる
                    - 公開鍵
                    - 秘密鍵
- 3月31日
- FE
    - JavaScript
        - 出力の方法(console.log以外の方法)
            - 文字列の出力
                - document.write
                    - ´´´JavaScript
                    document.write("<strong>Samurai</strong>");
                    ´´´
            - HTMLで記載された要素の出力
                - innerHTML
                    - idで指定した文字列
                - getElementByIdメソッド
                    id属性で指定した要素を取得する
    - 文の区切り、改行の判定方法は？
        - 文の区切り
            - コードの中で改行しても出力される時には改行されない
                - 式の終わりはセミコロンで指定する
                    - セミコロンはなくても成立するが明示的に記載する方がいい
        - 改行・区切り文字
            - エスケープシーケンス	意味
                - b	    バックスペース
                - t	    水平タブ
                - v	    垂直タブ (垂直方向に空白を入れる)
                - n	    改行
                - r	    復帰 (同じ行の先頭に移動)
                - f	    改ページ
                - ‘	    シングルクォーテーション
                - “	    ダブルクォーテーション
                - ¥¥	¥文字
                ^ ¥0	NULL文字
    - コメントアウトの方法
        - 行のコメントアウト
            - //で行のコメントアウト
        - 複数行でのコメントアウト（範囲指定）
            - /* と */で囲まれた範囲がコメントとして扱われる
        - その他
            - <!-- -->HTML-Like comment
            - #! Node.jsのプロボーザル
    - 数値の計算
        - 四則演算以外にもあるのか？
            - **(べき乗)
                - base数をexponent乗
                    - base数にそれ自身をexponent回掛けたしたものにします。
    - 演算子の種類(等価演算子、厳密等価演算子など以外)
        - インクリメント、デクリメント演算
            - ++ or --
        - ビット関連演算子
        - 左右シフト代入など
    - 条件を複数作りtrueになる条件を全て実行するメソッドなどはあるか？
        - for...in
            - オブジェクトに対し指定した変数を通じて反復処理を行う
                - それぞれのプロパティに対して指定した文を実行する
        - for...of
            - 反復可能オブジェクトに対して反復処理を発生させる
                - 反復処理を呼び出す
    - retrunのような処理を終了させるものはあるか？ 
        - プログラムを終了させる方法にexitがあるがそれはプログラム内では現実敵機ではない
        - try,catchを使う
            - エラーハンドリングを意識的に活用する方法
    - テンプレートリテラルの内部処理
        - テンプレートリテラルについて整理
            - テンプレートリテラルは文字列を表示するための手法
                ´´´JavaScript
                console.log(`Hello world`)
                // 改行
                console.log(`Hello
                world`);
                // 式
                console.log(`2 + 5 equal ${2 + 5}`);
                // 変数
                const person = 'JS Taro';
                console.log(`Hello ${person}`);
                ↓
                ![alt text](/Public/テンプレートリテラル.png.png)
                ´´´
            - テンプレートリテラルを使用すると便利な点がある
                - 改行文字を記載せずに改行が可能
                - 式においては＋が省略できる
                - 変数展開が可能（プレースホルダー）
            - 発展形としてタグ付きテンプレートがある
                - タグ付きテンプレートの宣言と関数の引用
    - 変数展開のテンプレートリテラル以外の方法
        - 変数展開をするのはテンプレートリテラル一択

4月1日
- JSにおける繰り返し処理の使いわけ
    - while
        - 最も原始的な繰り返し処理
            - 処理速度は最速になっている
    - for
        - while文に「事前処理文」、「繰り返し文」を加えたもの
            - イテレーターの処理には向かない
                - 配列の処理には向く
- イテレーターとは？
    - JSにおけるイテレーター
        - 終了時の返り値を定義する
            - next()メソッドを持つオブジェクトであるか？
                - nextメソッドを持つオブジェクトは無限、有限に限らず反復処理を行う事ができる
                    - 重要な事はnextメソッドがあるかないか？
- 配列の内部処理
    - 配列　＝＞　Arrayクラスのオブジェクト(Arrayオブジェクト)
        - データ型はなく型を指定する場合には型付き配列を使用する
        - 配列のコピー操作はシャローコピーになっている
        - 配列の各要素は厳密にはプロパティであるが、構文エラーが起きてしまう
            - そのためドット記法ではなくブランケット記法([]のような記載方法)を使う
                - ブランケット記法で記載された数値は内部でtoStringメソッドがかかり引用符で囲まれる
                    - これは"2"と"02"を区別するため
- undefinedの他に真偽値と近い概念を持つものはあるのか？
    - まず、undefinedは未定義の場合んび返される値となっている
        - undefinedはプリミティブ型である
            - 適応範囲：
                - 宣言のみが行われた変数
                - 実引数が存在しない仮引数に割り当てられるもの
- オブジェクトは何階層までいける？ 
    - ネストに制限はない
        - 現在のエンジニアにはネストを少なく、短いコードが良いと思っている人が多いが必ずそうならない可能性がある事も頭に入れておく
- 変数や定数を呼び出す場合は、定義元を参照している？
    - Rubyでは参照している
        - JSでも参照している
            - 内部処理をすっ飛ばして整理
                - 変数に対して値を代入するとその値を参照するものが生成される
                    - 変数は生成された値の参照を持っている状態になる
                        - 新しく変数を生成して変数を代入するとその変数が持っているある値への参照と同じものが変数の参照先になる
                            - その変数に対する参照を持っているのではなく、特定の値への参照をマッピングするという事
                                - 参照渡しではなく、参照先を指定しているという事になる
                                https://qiita.com/yuta0801/items/f8690a6e129c594de5fb#comments
- アロー関数の内部処理
    - ![alt text](/Public/JS関数記法による違い.png)
        - アロー関数と通常関数は同じように見えて実際は違うという事がわかる
            - 通常関数でできる事がアロー関数ではできなくなる
- 戻り値を持つのは関数のみ？
    - if文などは持つのか？
        - JSにおいてif文は条件式の判断をするのみの使用になっている
            - Rubyのようにif文自体が戻り値を持ち変数に対して代入する事などはしない
                - returnをする事で値を返す
- 定数などをいつまで保持するのか？
    - ガベレージコレクションなどを呼ばれる仕組み
        - JSにおいてもメモリ管理は行われている　＝＞　メモリサイクル
            - メモリの割り当てを行い、使わなくなったものに関しては破棄しメモリを解放する
                - 低水準言語の場合には明示的に行われる可能性があるが、高水準言語においては暗黙的に行われるのが一般的である
- 引数の受け取りは()がなくても成立するのか？
    - 引数の受け取りには()がなくても成立する
        - 但し、引数が１つのみの場合に限る

4月2日
- プロパティの値に入るもの
    - 基本的にはどのような値でも入る
- プロパティの値に入らないもの
    - 格納するとエラーになる
        - 存在しないファイルを指定する
        - ネットワークに接続していない状態でエンドポイントへのアクセスを行う
- 継承について
    - 継承されるもの
        - 継承とは特性を渡すという事である
            - JavaScriptにおいてはオブジェクトで値が管理される
                - プロトタイプチェーンを使ってプロトタイプオブジェクトを渡す、最終地点がnilを受け取るプロトタイプオブジェクトまで辿る
                    - 継承というのはこのプロトタイプオブジェクトを継承しているという事になる
    - 継承されないもの
        - privateに指定したものは継承されない
- readline-syncの内部処理
    - 調べたが内部処理について言及している記事はなく細かい事はわからなかった
        - しかし、Node.jsで多様されている模様
            - 入力している内容を***に変換する事も可能　＝＞　{hideEchoBack: true}
- defaultとnamedの違い
    - そもそもexportという概念
        - 特定のモジュールや関数、オブジェクトなどを他のファイルでも使う事ができるようにするもの
    - named
        - 1つのモジュールで複数exportする事ができる
            - エディターの補完機能が効きやすい
                - 呼び出す側は名前を指定する必要がある
    - default
        - 1つのモジュール内で1つだけexportできる
            - そのファイルの責務を1つに絞る
                - エディターの補完機能は使いずらい
    - まとめると
        - デフォルトでエクスポートするとそのファイルの責務が限定される
            - さらにエディターも効かない
        - namedは名前の指定が必要になるがファイルに制限をかけないかつエディターが効く
        
        　↓
        - 反対意見
            - 名前付きがある事でファイルの責務を超えてエクスポートしてしまう可能性が高くなる
- パッケージの分類
    - グローバルパッケージ
    - ローカルパッケージ
        - npmやyarnを使ってインストールする時の領域指示に関して
            - -gをつけるとglobal領域になる
- chalkパッケージを使うといろが変わる理由
    - より多くのスタイルオプションを提供する。
        - APIが少し複雑になる可能性あり
            - 多機能性を求める場合には適している。
- ディレクトリ構成の把握方法
    - ファイルタイプ